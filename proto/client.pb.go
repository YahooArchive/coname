// Code generated by protoc-gen-gogo.
// source: client.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		client.proto
		config.proto
		duration.proto
		keyserverconfig.proto
		keyserverlocal.proto
		replication.proto
		timestamp.proto
		tlsconfig.proto
		verifierconfig.proto
		verifierlocal.proto
		verifier.proto

	It has these top-level messages:
		LookupRequest
		UpdateRequest
		LookupProof
		TreeProof
		Entry
		SignedEntryUpdate
		Profile
		SignedEpochHead
		TimestampedEpochHead
		EpochHead
		AuthorizationPolicy
		PublicKey
		QuorumExpr
		EmailProof
		Config
		RealmConfig
		Duration
		ReplicaConfig
		KeyserverConfig
		RegistrationPolicy
		EmailProofByDKIM
		EmailProofByClientCert
		EmailProofByOIDC
		EmailProofBySAML
		OIDCConfig
		Replica
		ReplicaState
		KeyserverStep
		EpochDelimiter
		Timestamp
		TLSConfig
		CertificateAndKeyID
		VerifierConfig
		VerifierState
		VerifierStreamRequest
		VerifierStep
		Nothing
*/
package proto

import proto1 "github.com/andres-erbsen/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "gogoproto"

import bytes "bytes"

import strings "strings"
import github_com_andres_erbsen_protobuf_proto "github.com/andres-erbsen/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"
import github_com_andres_erbsen_protobuf_sortkeys "github.com/andres-erbsen/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LookupRequest struct {
	// Epoch as of which to perform the lookup ("latest" if not specified)
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// UserId will be mapped to an index by the server using VRF
	UserId string `protobuf:"bytes,2,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// quorum_requirement specifies which verifiers must have ratified the
	// result for it to be accepted. A server would fall back to an older
	// directory state if the ratifications of the latest one do not satisfy
	// the quorum requirement.
	QuorumRequirement *QuorumExpr `protobuf:"bytes,4,opt,name=quorum_requirement" json:"quorum_requirement,omitempty"`
}

func (m *LookupRequest) Reset()      { *m = LookupRequest{} }
func (*LookupRequest) ProtoMessage() {}

func (m *LookupRequest) GetQuorumRequirement() *QuorumExpr {
	if m != nil {
		return m.QuorumRequirement
	}
	return nil
}

// UpdateRequest specifies an update and the quorum required for
// considering the update successful. The server should respond with a lookup
// of the updated name with the specified parameters.
type UpdateRequest struct {
	// Update is passed on to verifiers.
	Update *SignedEntryUpdate `protobuf:"bytes,1,opt,name=update" json:"update,omitempty"`
	// Profile is included in the update request from the client to the
	// keyserver, but not passed on to the verifiers. The keyserver SHOULD
	// store it locally and include it in LookupProofs returned for lookups.
	// The verifiers MUST NOT try to read this field.
	// A keyserver MUST NOT discriminate users based on ther structure of their
	// profile other than enforcing a common-sense size limit. In particular, a
	// profile with fields that the keyserver does not understand or whose
	// values it considers invalid MUST be accepted.
	Profile          EncodedProfile `protobuf:"bytes,2,opt,name=profile,customtype=EncodedProfile" json:"profile"`
	LookupParameters *LookupRequest `protobuf:"bytes,3,opt,name=lookup_parameters" json:"lookup_parameters,omitempty"`
	EmailProof       *EmailProof    `protobuf:"bytes,1000,opt,name=email_proof" json:"email_proof,omitempty"`
}

func (m *UpdateRequest) Reset()      { *m = UpdateRequest{} }
func (*UpdateRequest) ProtoMessage() {}

func (m *UpdateRequest) GetUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateRequest) GetLookupParameters() *LookupRequest {
	if m != nil {
		return m.LookupParameters
	}
	return nil
}

func (m *UpdateRequest) GetEmailProof() *EmailProof {
	if m != nil {
		return m.EmailProof
	}
	return nil
}

// LookupProof encapsulates end-to-end cryptographc evidence that assuming *at
// least one* of the ratifiers has been correctly following the rules of the
// keyserver protocol then profile contains the latest public keys and metadata
// uploaded by user_id before the time specified in ratifications[0]. If any
// step of the proof does not check out, the contents of profile MUST NOT be
// used for any other purpose than debugging.
type LookupProof struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,proto3" json:"user_id,omitempty"`
	Index  []byte `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	// index_proof proves that index is a result of applying a globally fixed
	// bijection VRF to user_id: idx = VRF(user_ID). If this proof checks out,
	// we can safely continue by looking up the keyserver entry corresponding
	// to index to get the public key of user_id.
	IndexProof []byte `protobuf:"bytes,3,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// ratifications contains signed directory state summaries for the epoch under
	// which the lookup was performed.
	// A single valid ratification r by a honest and correct verifier implies
	// that the r.ratification.summary.root_hash summarizes the authenticated
	// data structure containing the unique and correct mapping from indices to
	// entries as of epoch r.ratification.epoch at human time
	// r.ratification.timestamp.
	// Each ratification must contain the same epoch head. A client MUST ignore a
	// proof if the ratifications do not satisfy its quorum requirement and MUST
	// require the keyserver itself to be in the quorum.
	Ratifications []*SignedEpochHead `protobuf:"bytes,4,rep,name=ratifications" json:"ratifications,omitempty"`
	// tree_proof contains an authenticated data structure lookup trace,
	// arguing that index maps to entry in the data structure with hash
	// ratifications[0].ratification.summary.root_hash.
	TreeProof *TreeProof `protobuf:"bytes,5,opt,name=tree_proof" json:"tree_proof,omitempty"`
	// Entry specifies profile by hash(profile) = entry.profile_hash
	Entry   *EncodedEntry   `protobuf:"bytes,6,opt,name=entry,customtype=EncodedEntry" json:"entry,omitempty"`
	Profile *EncodedProfile `protobuf:"bytes,7,opt,name=profile,customtype=EncodedProfile" json:"profile,omitempty"`
}

func (m *LookupProof) Reset()      { *m = LookupProof{} }
func (*LookupProof) ProtoMessage() {}

func (m *LookupProof) GetRatifications() []*SignedEpochHead {
	if m != nil {
		return m.Ratifications
	}
	return nil
}

func (m *LookupProof) GetTreeProof() *TreeProof {
	if m != nil {
		return m.TreeProof
	}
	return nil
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is or is not present in the tree.
type TreeProof struct {
	// Neighbors is a list of all the adjacent nodes along the path from the
	// bottommost node to the root. To save space, hashes for empty subtrees are
	// nil, and the number of hashes is equal to the length of the longest common
	// prefix with another entry in the tree (since a leaf node is moved up to
	// that point -- subtrees with a single entry are coalesced into a single
	// node).
	Neighbors [][]byte `protobuf:"bytes,1,rep,name=neighbors" json:"neighbors,omitempty"`
	// This is the index for the binding that does exist; it will share a prefix
	// with the requested index, but in case the leaf contains the wrong
	// contents, it will be different. It will be nil if the requested VRF falls
	// under an empty branch.
	ExistingIndex []byte `protobuf:"bytes,2,opt,name=existing_index,proto3" json:"existing_index,omitempty"`
	// This is the hash of the entry for the binding that does exist. If the leaf
	// contains the wrong contents, the client can use this to verify that the
	// incorrect leaf takes up the entire branch.
	ExistingEntryHash []byte `protobuf:"bytes,3,opt,name=existing_entry_hash,proto3" json:"existing_entry_hash,omitempty"`
}

func (m *TreeProof) Reset()      { *m = TreeProof{} }
func (*TreeProof) ProtoMessage() {}

// Entry is the value type in the authenticated mapping data structure.  The
// contents of all entries should be considered public (they are served to
// verifiers).
type Entry struct {
	// Index specifies the location of the entry in the authenticated
	// mapping data structure. It is computed as a verifiable random
	// function of the name: the keyserver can prove that index=vrf(name)
	// to anybody, but nobody else can compute vrf(name1). This is to
	// maintain the privacy of usernames.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// Version starts at 0 at registration and must not decrease. The keyserver
	// and verifiers MUST reject SignedEntryUpdates which violate these rules.
	// The purpose of this is to prevent an attacker from replaying a
	// SignedEntryUpdate that publishes a key that the attacker has gained
	// control of. On the other hand, increases by more than one are allowed: a
	// user should be allowed to generate a long-lived offline revocation
	// certificate that is valid even after they make some other change to
	// their profile. Nevertheless, unless explicitly required otherwise,
	// clients should increase the version number by exactly one on each
	// update.
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// UpdatePolicy will be used to verify SignedEntryUpdates to this
	// entry. It is NOT used for encryption, and SHOULD be ignored by
	// applications that do not intend to manage the user's profile. It has
	// also been called "the public key of the profile signing key" or "the
	// public identity key". A keyserver MUST NOT discriminate users based on
	// ther structure of their update_key other than (1) as specified in
	// SignedEntryUpdate and (2) common-sense limits on the total size of an
	// entry to limit storage cost.
	UpdatePolicy *AuthorizationPolicy `protobuf:"bytes,3,opt,name=update_policy" json:"update_policy,omitempty"`
	// ProfileCommitment uniquely specifies the profile without revealing its
	// contents. The commitment is computed as commitment =
	// sha3shake256(profile); the contents contain a nonce.
	ProfileCommitment []byte `protobuf:"bytes,4,opt,name=profile_commitment,proto3" json:"profile_commitment,omitempty"`
}

func (m *Entry) Reset()      { *m = Entry{} }
func (*Entry) ProtoMessage() {}

func (m *Entry) GetUpdatePolicy() *AuthorizationPolicy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

// SignedEntryUpdate is the minimal self-contained structure to justify
// changing the value of an entry. In the state machine model of a namespace,
// SignedEntryUpdate is the main input type.
type SignedEntryUpdate struct {
	NewEntry EncodedEntry `protobuf:"bytes,1,opt,name=new_entry,customtype=EncodedEntry" json:"new_entry"`
	// NewSig, if successfully verified using update.new_entry.update_key,
	// confirms that the new entry is willing to be bound to this index.
	// Both the keyserver and verifiers MUST check these signatures against the
	// old profile's authorization policy AND the new profile's authorization
	// policy. All signatures are tagged with ID of the public key that
	// generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()      { *m = SignedEntryUpdate{} }
func (*SignedEntryUpdate) ProtoMessage() {}

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// A user's profile, containing public keys and other information.
// A new field will be added here for each application, with the TCP/UDP port
// number as field number whenever possible to avoid collisions.
type Profile struct {
	// Nonce containst at least 16 bytes (and counts towards the total profile
	// size limit). Having a nonce in each profile ensures that an attacker
	// can't guess-and-check somebody's profile contents using Entry.profile_hash.
	// It is the client's responsibility to generate a random nonce to protect the
	// privacy of its profile, thus the presence of this field is not checked by
	// the server.
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Application-specific public keys. The map is keyed by application ID.
	Keys map[string][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()      { *m = Profile{} }
func (*Profile) ProtoMessage() {}

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// SignedEpochHead messages are used by auditors and the service provider to
// vouch that the SummaryHash represents the correct unique global state at the
// end of epoch. In particular, it means that the signer has enforced the
// profile update policy specified in the doc-comments of SignedEntryUpdate and
// Profile for the specified epoch AND all prior epochs. A Ratification MUST
// NOT be signed in any other circumstances.
type SignedEpochHead struct {
	Head EncodedTimestampedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedTimestampedEpochHead" json:"head"`
	// Signatures is used for authentication of ratification and MUST be
	// verified before interpreting any contents of ratification.
	// All signatures are tagged with ID of the public key that generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()      { *m = SignedEpochHead{} }
func (*SignedEpochHead) ProtoMessage() {}

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type TimestampedEpochHead struct {
	// EpochHead specifies the entire state and history of the
	// realm.
	Head EncodedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedEpochHead" json:"head"`
	// Timestamp specifies when the requirements for SignedEpochHead
	// were checked. Clients will accept a SignedEpochHead timestamped at most a
	// fixed amount of time into the past, and MUST fail secure if the timestamp
	// is not fresh because the directory state may have changed. The signature
	// expiration tolerance plus the maximum clock skew between a pair of clients
	// is the maximum propogation time of a change from one to another after which
	// even a malicious keyserver will not be able to convince a client to a
	// accept the previous state (assuming that all quorums the client considers
	// sufficient contain a correct and honest server).
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *TimestampedEpochHead) Reset()      { *m = TimestampedEpochHead{} }
func (*TimestampedEpochHead) ProtoMessage() {}

func (m *TimestampedEpochHead) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

type EpochHead struct {
	// Realm is the fully-qualified domain name of the keyserver whose
	// state is being ratified.
	Realm string `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty"`
	// Epoch is a sequence number tracking distinct ratified states.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// RootHash specifies the authenticated data structure.
	RootHash []byte `protobuf:"bytes,3,opt,name=root_hash,proto3" json:"root_hash,omitempty"`
	// IssueTime is the time when this epoch was released. All epochs for the
	// same keyserver MUST have non-decreasing IssueTimes.
	IssueTime Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time"`
	// PreviousSummaryHash chaining is used to allow signatures from
	// different epochs in the same quorum: a signature vouches for all
	// epochs chained to that in addition to the one listed.
	// Each PreviousSummaryHash depends on PreviousSummary, therefore
	// (by induction on the hash-pointer structure) a
	// PreviousSummeryHash for some epoch specifies the states of all
	// previous epochs. This hash uses SHA3-SHAKE256 with 64 bytes of output.
	PreviousSummaryHash []byte `protobuf:"bytes,5,opt,name=previous_summary_hash,proto3" json:"previous_summary_hash,omitempty"`
	// NextEpochPolicy allows for automated server key rollover: the new key(s)
	// are signed by the current one as a part of the epoch. This field is nil
	// if no key change is requested. If the server key is distributed with the
	// client software and benefits from reliable automated updates, clients
	// MAY ignore this field.
	NextEpochPolicy AuthorizationPolicy `protobuf:"bytes,6,opt,name=next_epoch_policy" json:"next_epoch_policy"`
}

func (m *EpochHead) Reset()      { *m = EpochHead{} }
func (*EpochHead) ProtoMessage() {}

func (m *EpochHead) GetIssueTime() Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return Timestamp{}
}

func (m *EpochHead) GetNextEpochPolicy() AuthorizationPolicy {
	if m != nil {
		return m.NextEpochPolicy
	}
	return AuthorizationPolicy{}
}

// AuthorizationPolicy is used to check whether some signatures make up
// sufficient authorization to back an action.
// This is used to implement the following:
// 1. Account Recovery through service provider: if an user's entry has the
// update key set to threshold(1,user,serviceprovider), the service
// provider can perform account recovery. Note that a third party will not
// necessarily know who the subkeys are held by. Thus, the client
// implementation MUST require a signed certificate confirming possession
// of the secret key and promising to do no evil from every trustee whose
// key is used for recovery in this manner.
// 2. Service providers with servers in geographically diverse locations
// can use a threshold to limit the damage the compromise or loss of one
// replica can do. Example threshold(2,freedonia,gilead,mordor).
// 3. Adaptive key rollover during cryptocalypse.
type AuthorizationPolicy struct {
	PublicKeys map[uint64]*PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Types that are valid to be assigned to PolicyType:
	//	*AuthorizationPolicy_Quorum
	PolicyType isAuthorizationPolicy_PolicyType `protobuf_oneof:"policy_type"`
}

func (m *AuthorizationPolicy) Reset()      { *m = AuthorizationPolicy{} }
func (*AuthorizationPolicy) ProtoMessage() {}

type isAuthorizationPolicy_PolicyType interface {
	isAuthorizationPolicy_PolicyType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthorizationPolicy_Quorum struct {
	Quorum *QuorumExpr `protobuf:"bytes,2,opt,name=quorum,oneof"`
}

func (*AuthorizationPolicy_Quorum) isAuthorizationPolicy_PolicyType() {}

func (m *AuthorizationPolicy) GetPolicyType() isAuthorizationPolicy_PolicyType {
	if m != nil {
		return m.PolicyType
	}
	return nil
}

func (m *AuthorizationPolicy) GetPublicKeys() map[uint64]*PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *AuthorizationPolicy) GetQuorum() *QuorumExpr {
	if x, ok := m.GetPolicyType().(*AuthorizationPolicy_Quorum); ok {
		return x.Quorum
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AuthorizationPolicy) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _AuthorizationPolicy_OneofMarshaler, _AuthorizationPolicy_OneofUnmarshaler, []interface{}{
		(*AuthorizationPolicy_Quorum)(nil),
	}
}

func _AuthorizationPolicy_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*AuthorizationPolicy)
	// policy_type
	switch x := m.PolicyType.(type) {
	case *AuthorizationPolicy_Quorum:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Quorum); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AuthorizationPolicy.PolicyType has unexpected type %T", x)
	}
	return nil
}

func _AuthorizationPolicy_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*AuthorizationPolicy)
	switch tag {
	case 2: // policy_type.quorum
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(QuorumExpr)
		err := b.DecodeMessage(msg)
		m.PolicyType = &AuthorizationPolicy_Quorum{msg}
		return true, err
	default:
		return false, nil
	}
}

// PublicKey wraps a public key of a cryptographically secure signature
// scheme and verification metadata. Each verifier can have its own signature
// format and needs to implement serialization and deserialization of its own
// signatures. The ID of a public key is defined as the 64-bit SHAKE256 hash of
// the protobuf-encoded public key (and interpreted as little-endian when a
// numeric representation is required).
type PublicKey struct {
	// Types that are valid to be assigned to PubkeyType:
	//	*PublicKey_Ed25519
	PubkeyType isPublicKey_PubkeyType `protobuf_oneof:"pubkey_type"`
}

func (m *PublicKey) Reset()      { *m = PublicKey{} }
func (*PublicKey) ProtoMessage() {}

type isPublicKey_PubkeyType interface {
	isPublicKey_PubkeyType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type PublicKey_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3,oneof"`
}

func (*PublicKey_Ed25519) isPublicKey_PubkeyType() {}

func (m *PublicKey) GetPubkeyType() isPublicKey_PubkeyType {
	if m != nil {
		return m.PubkeyType
	}
	return nil
}

func (m *PublicKey) GetEd25519() []byte {
	if x, ok := m.GetPubkeyType().(*PublicKey_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PublicKey) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _PublicKey_OneofMarshaler, _PublicKey_OneofUnmarshaler, []interface{}{
		(*PublicKey_Ed25519)(nil),
	}
}

func _PublicKey_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*PublicKey)
	// pubkey_type
	switch x := m.PubkeyType.(type) {
	case *PublicKey_Ed25519:
		_ = b.EncodeVarint(1<<3 | proto1.WireBytes)
		_ = b.EncodeRawBytes(x.Ed25519)
	case nil:
	default:
		return fmt.Errorf("PublicKey.PubkeyType has unexpected type %T", x)
	}
	return nil
}

func _PublicKey_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*PublicKey)
	switch tag {
	case 1: // pubkey_type.ed25519
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.PubkeyType = &PublicKey_Ed25519{x}
		return true, err
	default:
		return false, nil
	}
}

// QuorumExpr represents a function with type set<uint64> -> bool. An
// expression evaluates to true given args iff the sum of the following two
// numbers is at least threshold:
// - number of entries in verifiers that are in args
// - number of subexpressions that evaluate to true
// note: expr.eval(a) \wedge expr.eval(b) -> expr.eval(a \cup b)
type QuorumExpr struct {
	Threshold  uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Candidates []uint64 `protobuf:"fixed64,2,rep,name=candidates" json:"candidates,omitempty"`
	// QuorumExpr allows expressing contitions of the form "two out of these
	// and three out of those".
	// If an implementation chooses to ban recursive thresholding, it can do so
	// ignoring this field. However, doing so is NOT SUPPORTED.
	Subexpressions []*QuorumExpr `protobuf:"bytes,3,rep,name=subexpressions" json:"subexpressions,omitempty"`
}

func (m *QuorumExpr) Reset()      { *m = QuorumExpr{} }
func (*QuorumExpr) ProtoMessage() {}

func (m *QuorumExpr) GetSubexpressions() []*QuorumExpr {
	if m != nil {
		return m.Subexpressions
	}
	return nil
}

// EmailProof provides a proof of ownership of the email address
type EmailProof struct {
	// Types that are valid to be assigned to ProofType:
	//	*EmailProof_DKIMProof
	//	*EmailProof_OIDCToken
	//	*EmailProof_SAMLResponse
	ProofType isEmailProof_ProofType `protobuf_oneof:"proof_type"`
}

func (m *EmailProof) Reset()      { *m = EmailProof{} }
func (*EmailProof) ProtoMessage() {}

type isEmailProof_ProofType interface {
	isEmailProof_ProofType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type EmailProof_DKIMProof struct {
	DKIMProof []byte `protobuf:"bytes,1,opt,name=dkim_proof,proto3,oneof"`
}
type EmailProof_OIDCToken struct {
	OIDCToken string `protobuf:"bytes,2,opt,name=oidc_token,proto3,oneof"`
}
type EmailProof_SAMLResponse struct {
	SAMLResponse string `protobuf:"bytes,3,opt,name=saml_response,proto3,oneof"`
}

func (*EmailProof_DKIMProof) isEmailProof_ProofType()    {}
func (*EmailProof_OIDCToken) isEmailProof_ProofType()    {}
func (*EmailProof_SAMLResponse) isEmailProof_ProofType() {}

func (m *EmailProof) GetProofType() isEmailProof_ProofType {
	if m != nil {
		return m.ProofType
	}
	return nil
}

func (m *EmailProof) GetDKIMProof() []byte {
	if x, ok := m.GetProofType().(*EmailProof_DKIMProof); ok {
		return x.DKIMProof
	}
	return nil
}

func (m *EmailProof) GetOIDCToken() string {
	if x, ok := m.GetProofType().(*EmailProof_OIDCToken); ok {
		return x.OIDCToken
	}
	return ""
}

func (m *EmailProof) GetSAMLResponse() string {
	if x, ok := m.GetProofType().(*EmailProof_SAMLResponse); ok {
		return x.SAMLResponse
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EmailProof) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _EmailProof_OneofMarshaler, _EmailProof_OneofUnmarshaler, []interface{}{
		(*EmailProof_DKIMProof)(nil),
		(*EmailProof_OIDCToken)(nil),
		(*EmailProof_SAMLResponse)(nil),
	}
}

func _EmailProof_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*EmailProof)
	// proof_type
	switch x := m.ProofType.(type) {
	case *EmailProof_DKIMProof:
		_ = b.EncodeVarint(1<<3 | proto1.WireBytes)
		_ = b.EncodeRawBytes(x.DKIMProof)
	case *EmailProof_OIDCToken:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		_ = b.EncodeStringBytes(x.OIDCToken)
	case *EmailProof_SAMLResponse:
		_ = b.EncodeVarint(3<<3 | proto1.WireBytes)
		_ = b.EncodeStringBytes(x.SAMLResponse)
	case nil:
	default:
		return fmt.Errorf("EmailProof.ProofType has unexpected type %T", x)
	}
	return nil
}

func _EmailProof_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*EmailProof)
	switch tag {
	case 1: // proof_type.dkim_proof
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ProofType = &EmailProof_DKIMProof{x}
		return true, err
	case 2: // proof_type.oidc_token
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ProofType = &EmailProof_OIDCToken{x}
		return true, err
	case 3: // proof_type.saml_response
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ProofType = &EmailProof_SAMLResponse{x}
		return true, err
	default:
		return false, nil
	}
}

func (this *LookupRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return fmt.Errorf("that is not of type *LookupRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupRequestbut is not nil && this == nil")
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return fmt.Errorf("QuorumRequirement this(%v) Not Equal that(%v)", this.QuorumRequirement, that1.QuorumRequirement)
	}
	return nil
}
func (this *LookupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return false
	}
	return true
}
func (this *UpdateRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return fmt.Errorf("that is not of type *UpdateRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateRequestbut is not nil && this == nil")
	}
	if !this.Update.Equal(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", this.Update, that1.Update)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return fmt.Errorf("LookupParameters this(%v) Not Equal that(%v)", this.LookupParameters, that1.LookupParameters)
	}
	if !this.EmailProof.Equal(that1.EmailProof) {
		return fmt.Errorf("EmailProof this(%v) Not Equal that(%v)", this.EmailProof, that1.EmailProof)
	}
	return nil
}
func (this *UpdateRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return false
	}
	if !this.EmailProof.Equal(that1.EmailProof) {
		return false
	}
	return true
}
func (this *LookupProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return fmt.Errorf("that is not of type *LookupProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupProofbut is not nil && this == nil")
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return fmt.Errorf("IndexProof this(%v) Not Equal that(%v)", this.IndexProof, that1.IndexProof)
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return fmt.Errorf("Ratifications this(%v) Not Equal that(%v)", len(this.Ratifications), len(that1.Ratifications))
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return fmt.Errorf("Ratifications this[%v](%v) Not Equal that[%v](%v)", i, this.Ratifications[i], i, that1.Ratifications[i])
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return fmt.Errorf("TreeProof this(%v) Not Equal that(%v)", this.TreeProof, that1.TreeProof)
	}
	if that1.Entry == nil {
		if this.Entry != nil {
			return fmt.Errorf("this.Entry != nil && that1.Entry == nil")
		}
	} else if !this.Entry.Equal(*that1.Entry) {
		return fmt.Errorf("Entry this(%v) Not Equal that(%v)", this.Entry, that1.Entry)
	}
	if that1.Profile == nil {
		if this.Profile != nil {
			return fmt.Errorf("this.Profile != nil && that1.Profile == nil")
		}
	} else if !this.Profile.Equal(*that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	return nil
}
func (this *LookupProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return false
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return false
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return false
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return false
	}
	if that1.Entry == nil {
		if this.Entry != nil {
			return false
		}
	} else if !this.Entry.Equal(*that1.Entry) {
		return false
	}
	if that1.Profile == nil {
		if this.Profile != nil {
			return false
		}
	} else if !this.Profile.Equal(*that1.Profile) {
		return false
	}
	return true
}
func (this *TreeProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return fmt.Errorf("that is not of type *TreeProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TreeProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TreeProofbut is not nil && this == nil")
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return fmt.Errorf("Neighbors this(%v) Not Equal that(%v)", len(this.Neighbors), len(that1.Neighbors))
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return fmt.Errorf("Neighbors this[%v](%v) Not Equal that[%v](%v)", i, this.Neighbors[i], i, that1.Neighbors[i])
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return fmt.Errorf("ExistingIndex this(%v) Not Equal that(%v)", this.ExistingIndex, that1.ExistingIndex)
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return fmt.Errorf("ExistingEntryHash this(%v) Not Equal that(%v)", this.ExistingEntryHash, that1.ExistingEntryHash)
	}
	return nil
}
func (this *TreeProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return false
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return false
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return false
	}
	return true
}
func (this *Entry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Entry)
	if !ok {
		return fmt.Errorf("that is not of type *Entry")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Entry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Entrybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return fmt.Errorf("UpdatePolicy this(%v) Not Equal that(%v)", this.UpdatePolicy, that1.UpdatePolicy)
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return fmt.Errorf("ProfileCommitment this(%v) Not Equal that(%v)", this.ProfileCommitment, that1.ProfileCommitment)
	}
	return nil
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Entry)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return false
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return false
	}
	return true
}
func (this *SignedEntryUpdate) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEntryUpdate")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEntryUpdate but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEntryUpdatebut is not nil && this == nil")
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return fmt.Errorf("NewEntry this(%v) Not Equal that(%v)", this.NewEntry, that1.NewEntry)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEntryUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *Profile) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Profile)
	if !ok {
		return fmt.Errorf("that is not of type *Profile")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Profile but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Profilebut is not nil && this == nil")
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if len(this.Keys) != len(that1.Keys) {
		return fmt.Errorf("Keys this(%v) Not Equal that(%v)", len(this.Keys), len(that1.Keys))
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return fmt.Errorf("Keys this[%v](%v) Not Equal that[%v](%v)", i, this.Keys[i], i, that1.Keys[i])
		}
	}
	return nil
}
func (this *Profile) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Profile)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *SignedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *TimestampedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *TimestampedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TimestampedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TimestampedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	return nil
}
func (this *TimestampedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *EpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *EpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EpochHeadbut is not nil && this == nil")
	}
	if this.Realm != that1.Realm {
		return fmt.Errorf("Realm this(%v) Not Equal that(%v)", this.Realm, that1.Realm)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return fmt.Errorf("RootHash this(%v) Not Equal that(%v)", this.RootHash, that1.RootHash)
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return fmt.Errorf("IssueTime this(%v) Not Equal that(%v)", this.IssueTime, that1.IssueTime)
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return fmt.Errorf("PreviousSummaryHash this(%v) Not Equal that(%v)", this.PreviousSummaryHash, that1.PreviousSummaryHash)
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return fmt.Errorf("NextEpochPolicy this(%v) Not Equal that(%v)", this.NextEpochPolicy, that1.NextEpochPolicy)
	}
	return nil
}
func (this *EpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Realm != that1.Realm {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return false
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return false
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return false
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicybut is not nil && this == nil")
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return fmt.Errorf("PublicKeys this(%v) Not Equal that(%v)", len(this.PublicKeys), len(that1.PublicKeys))
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return fmt.Errorf("PublicKeys this[%v](%v) Not Equal that[%v](%v)", i, this.PublicKeys[i], i, that1.PublicKeys[i])
		}
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return fmt.Errorf("this.PolicyType != nil && that1.PolicyType == nil")
		}
	} else if this.PolicyType == nil {
		return fmt.Errorf("this.PolicyType == nil && that1.PolicyType != nil")
	} else if err := this.PolicyType.VerboseEqual(that1.PolicyType); err != nil {
		return err
	}
	return nil
}
func (this *AuthorizationPolicy_Quorum) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy_Quorum)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy_Quorum")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy_Quorum but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicy_Quorumbut is not nil && this == nil")
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return fmt.Errorf("Quorum this(%v) Not Equal that(%v)", this.Quorum, that1.Quorum)
	}
	return nil
}
func (this *AuthorizationPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return false
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return false
		}
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return false
		}
	} else if this.PolicyType == nil {
		return false
	} else if !this.PolicyType.Equal(that1.PolicyType) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy_Quorum) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy_Quorum)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return false
	}
	return true
}
func (this *PublicKey) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKeybut is not nil && this == nil")
	}
	if that1.PubkeyType == nil {
		if this.PubkeyType != nil {
			return fmt.Errorf("this.PubkeyType != nil && that1.PubkeyType == nil")
		}
	} else if this.PubkeyType == nil {
		return fmt.Errorf("this.PubkeyType == nil && that1.PubkeyType != nil")
	} else if err := this.PubkeyType.VerboseEqual(that1.PubkeyType); err != nil {
		return err
	}
	return nil
}
func (this *PublicKey_Ed25519) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey_Ed25519)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey_Ed25519")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey_Ed25519 but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKey_Ed25519but is not nil && this == nil")
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return fmt.Errorf("Ed25519 this(%v) Not Equal that(%v)", this.Ed25519, that1.Ed25519)
	}
	return nil
}
func (this *PublicKey) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.PubkeyType == nil {
		if this.PubkeyType != nil {
			return false
		}
	} else if this.PubkeyType == nil {
		return false
	} else if !this.PubkeyType.Equal(that1.PubkeyType) {
		return false
	}
	return true
}
func (this *PublicKey_Ed25519) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey_Ed25519)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return false
	}
	return true
}
func (this *QuorumExpr) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return fmt.Errorf("that is not of type *QuorumExpr")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *QuorumExpr but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *QuorumExprbut is not nil && this == nil")
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return fmt.Errorf("Candidates this(%v) Not Equal that(%v)", len(this.Candidates), len(that1.Candidates))
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return fmt.Errorf("Candidates this[%v](%v) Not Equal that[%v](%v)", i, this.Candidates[i], i, that1.Candidates[i])
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return fmt.Errorf("Subexpressions this(%v) Not Equal that(%v)", len(this.Subexpressions), len(that1.Subexpressions))
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return fmt.Errorf("Subexpressions this[%v](%v) Not Equal that[%v](%v)", i, this.Subexpressions[i], i, that1.Subexpressions[i])
		}
	}
	return nil
}
func (this *QuorumExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return false
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return false
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return false
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return false
		}
	}
	return true
}
func (this *EmailProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProof)
	if !ok {
		return fmt.Errorf("that is not of type *EmailProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProofbut is not nil && this == nil")
	}
	if that1.ProofType == nil {
		if this.ProofType != nil {
			return fmt.Errorf("this.ProofType != nil && that1.ProofType == nil")
		}
	} else if this.ProofType == nil {
		return fmt.Errorf("this.ProofType == nil && that1.ProofType != nil")
	} else if err := this.ProofType.VerboseEqual(that1.ProofType); err != nil {
		return err
	}
	return nil
}
func (this *EmailProof_DKIMProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProof_DKIMProof)
	if !ok {
		return fmt.Errorf("that is not of type *EmailProof_DKIMProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProof_DKIMProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProof_DKIMProofbut is not nil && this == nil")
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return fmt.Errorf("DKIMProof this(%v) Not Equal that(%v)", this.DKIMProof, that1.DKIMProof)
	}
	return nil
}
func (this *EmailProof_OIDCToken) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProof_OIDCToken)
	if !ok {
		return fmt.Errorf("that is not of type *EmailProof_OIDCToken")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProof_OIDCToken but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProof_OIDCTokenbut is not nil && this == nil")
	}
	if this.OIDCToken != that1.OIDCToken {
		return fmt.Errorf("OIDCToken this(%v) Not Equal that(%v)", this.OIDCToken, that1.OIDCToken)
	}
	return nil
}
func (this *EmailProof_SAMLResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProof_SAMLResponse)
	if !ok {
		return fmt.Errorf("that is not of type *EmailProof_SAMLResponse")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProof_SAMLResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProof_SAMLResponsebut is not nil && this == nil")
	}
	if this.SAMLResponse != that1.SAMLResponse {
		return fmt.Errorf("SAMLResponse this(%v) Not Equal that(%v)", this.SAMLResponse, that1.SAMLResponse)
	}
	return nil
}
func (this *EmailProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.ProofType == nil {
		if this.ProofType != nil {
			return false
		}
	} else if this.ProofType == nil {
		return false
	} else if !this.ProofType.Equal(that1.ProofType) {
		return false
	}
	return true
}
func (this *EmailProof_DKIMProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProof_DKIMProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return false
	}
	return true
}
func (this *EmailProof_OIDCToken) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProof_OIDCToken)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OIDCToken != that1.OIDCToken {
		return false
	}
	return true
}
func (this *EmailProof_SAMLResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProof_SAMLResponse)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SAMLResponse != that1.SAMLResponse {
		return false
	}
	return true
}
func (this *LookupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.LookupRequest{")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.QuorumRequirement != nil {
		s = append(s, "QuorumRequirement: "+fmt.Sprintf("%#v", this.QuorumRequirement)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.UpdateRequest{")
	if this.Update != nil {
		s = append(s, "Update: "+fmt.Sprintf("%#v", this.Update)+",\n")
	}
	s = append(s, "Profile: "+strings.Replace(this.Profile.GoString(), `&`, ``, 1)+",\n")
	if this.LookupParameters != nil {
		s = append(s, "LookupParameters: "+fmt.Sprintf("%#v", this.LookupParameters)+",\n")
	}
	if this.EmailProof != nil {
		s = append(s, "EmailProof: "+fmt.Sprintf("%#v", this.EmailProof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LookupProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&proto.LookupProof{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "IndexProof: "+fmt.Sprintf("%#v", this.IndexProof)+",\n")
	if this.Ratifications != nil {
		s = append(s, "Ratifications: "+fmt.Sprintf("%#v", this.Ratifications)+",\n")
	}
	if this.TreeProof != nil {
		s = append(s, "TreeProof: "+fmt.Sprintf("%#v", this.TreeProof)+",\n")
	}
	if this.Entry != nil {
		s = append(s, "Entry: "+fmt.Sprintf("%#v", this.Entry)+",\n")
	}
	if this.Profile != nil {
		s = append(s, "Profile: "+fmt.Sprintf("%#v", this.Profile)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.TreeProof{")
	s = append(s, "Neighbors: "+fmt.Sprintf("%#v", this.Neighbors)+",\n")
	s = append(s, "ExistingIndex: "+fmt.Sprintf("%#v", this.ExistingIndex)+",\n")
	s = append(s, "ExistingEntryHash: "+fmt.Sprintf("%#v", this.ExistingEntryHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.Entry{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.UpdatePolicy != nil {
		s = append(s, "UpdatePolicy: "+fmt.Sprintf("%#v", this.UpdatePolicy)+",\n")
	}
	s = append(s, "ProfileCommitment: "+fmt.Sprintf("%#v", this.ProfileCommitment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedEntryUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.SignedEntryUpdate{")
	s = append(s, "NewEntry: "+strings.Replace(this.NewEntry.GoString(), `&`, ``, 1)+",\n")
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	if this.Signatures != nil {
		s = append(s, "Signatures: "+mapStringForSignatures+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Profile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.Profile{")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%#v: %#v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	if this.Keys != nil {
		s = append(s, "Keys: "+mapStringForKeys+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.SignedEpochHead{")
	s = append(s, "Head: "+strings.Replace(this.Head.GoString(), `&`, ``, 1)+",\n")
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	if this.Signatures != nil {
		s = append(s, "Signatures: "+mapStringForSignatures+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimestampedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.TimestampedEpochHead{")
	s = append(s, "Head: "+strings.Replace(this.Head.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Timestamp: "+strings.Replace(this.Timestamp.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto.EpochHead{")
	s = append(s, "Realm: "+fmt.Sprintf("%#v", this.Realm)+",\n")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "RootHash: "+fmt.Sprintf("%#v", this.RootHash)+",\n")
	s = append(s, "IssueTime: "+strings.Replace(this.IssueTime.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "PreviousSummaryHash: "+fmt.Sprintf("%#v", this.PreviousSummaryHash)+",\n")
	s = append(s, "NextEpochPolicy: "+strings.Replace(this.NextEpochPolicy.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.AuthorizationPolicy{")
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%#v: %#v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	if this.PublicKeys != nil {
		s = append(s, "PublicKeys: "+mapStringForPublicKeys+",\n")
	}
	if this.PolicyType != nil {
		s = append(s, "PolicyType: "+fmt.Sprintf("%#v", this.PolicyType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationPolicy_Quorum) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.AuthorizationPolicy_Quorum{` +
		`Quorum:` + fmt.Sprintf("%#v", this.Quorum) + `}`}, ", ")
	return s
}
func (this *PublicKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.PublicKey{")
	if this.PubkeyType != nil {
		s = append(s, "PubkeyType: "+fmt.Sprintf("%#v", this.PubkeyType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PublicKey_Ed25519) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.PublicKey_Ed25519{` +
		`Ed25519:` + fmt.Sprintf("%#v", this.Ed25519) + `}`}, ", ")
	return s
}
func (this *QuorumExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.QuorumExpr{")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "Candidates: "+fmt.Sprintf("%#v", this.Candidates)+",\n")
	if this.Subexpressions != nil {
		s = append(s, "Subexpressions: "+fmt.Sprintf("%#v", this.Subexpressions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmailProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.EmailProof{")
	if this.ProofType != nil {
		s = append(s, "ProofType: "+fmt.Sprintf("%#v", this.ProofType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmailProof_DKIMProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.EmailProof_DKIMProof{` +
		`DKIMProof:` + fmt.Sprintf("%#v", this.DKIMProof) + `}`}, ", ")
	return s
}
func (this *EmailProof_OIDCToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.EmailProof_OIDCToken{` +
		`OIDCToken:` + fmt.Sprintf("%#v", this.OIDCToken) + `}`}, ", ")
	return s
}
func (this *EmailProof_SAMLResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.EmailProof_SAMLResponse{` +
		`SAMLResponse:` + fmt.Sprintf("%#v", this.SAMLResponse) + `}`}, ", ")
	return s
}
func valueToGoStringClient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringClient(e map[int32]github_com_andres_erbsen_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for E2EKSPublic service

type E2EKSPublicClient interface {
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error)
}

type e2EKSPublicClient struct {
	cc *grpc.ClientConn
}

func NewE2EKSPublicClient(cc *grpc.ClientConn) E2EKSPublicClient {
	return &e2EKSPublicClient{cc}
}

func (c *e2EKSPublicClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKSPublicClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKSPublic service

type E2EKSPublicServer interface {
	Lookup(context.Context, *LookupRequest) (*LookupProof, error)
	Update(context.Context, *UpdateRequest) (*LookupProof, error)
}

func RegisterE2EKSPublicServer(s *grpc.Server, srv E2EKSPublicServer) {
	s.RegisterService(&_E2EKSPublic_serviceDesc, srv)
}

func _E2EKSPublic_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(E2EKSPublicServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.E2EKSPublic/Lookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(E2EKSPublicServer).Lookup(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _E2EKSPublic_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(E2EKSPublicServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.E2EKSPublic/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(E2EKSPublicServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _E2EKSPublic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.E2EKSPublic",
	HandlerType: (*E2EKSPublicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _E2EKSPublic_Lookup_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _E2EKSPublic_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *LookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if len(m.UserId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.QuorumRequirement != nil {
		data[i] = 0x22
		i++
		i = encodeVarintClient(data, i, uint64(m.QuorumRequirement.Size()))
		n1, err := m.QuorumRequirement.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *UpdateRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(m.Update.Size()))
		n2, err := m.Update.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
	n3, err := m.Profile.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.LookupParameters != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.LookupParameters.Size()))
		n4, err := m.LookupParameters.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.EmailProof != nil {
		data[i] = 0xc2
		i++
		data[i] = 0x3e
		i++
		i = encodeVarintClient(data, i, uint64(m.EmailProof.Size()))
		n5, err := m.EmailProof.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LookupProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.IndexProof != nil {
		if len(m.IndexProof) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.IndexProof)))
			i += copy(data[i:], m.IndexProof)
		}
	}
	if len(m.Ratifications) > 0 {
		for _, msg := range m.Ratifications {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TreeProof != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintClient(data, i, uint64(m.TreeProof.Size()))
		n6, err := m.TreeProof.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Entry != nil {
		data[i] = 0x32
		i++
		i = encodeVarintClient(data, i, uint64(m.Entry.Size()))
		n7, err := m.Entry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Profile != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
		n8, err := m.Profile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *TreeProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.ExistingIndex != nil {
		if len(m.ExistingIndex) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingIndex)))
			i += copy(data[i:], m.ExistingIndex)
		}
	}
	if m.ExistingEntryHash != nil {
		if len(m.ExistingEntryHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingEntryHash)))
			i += copy(data[i:], m.ExistingEntryHash)
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.UpdatePolicy.Size()))
		n9, err := m.UpdatePolicy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ProfileCommitment != nil {
		if len(m.ProfileCommitment) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ProfileCommitment)))
			i += copy(data[i:], m.ProfileCommitment)
		}
	}
	return i, nil
}

func (m *SignedEntryUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEntryUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.NewEntry.Size()))
	n10, err := m.NewEntry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Profile) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Profile) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nonce != nil {
		if len(m.Nonce) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Nonce)))
			i += copy(data[i:], m.Nonce)
		}
	}
	if len(m.Keys) > 0 {
		keysForKeys := make([]string, 0, len(m.Keys))
		for k, _ := range m.Keys {
			keysForKeys = append(keysForKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
		for _, k := range keysForKeys {
			data[i] = 0x12
			i++
			v := m.Keys[k]
			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *SignedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n11, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *TimestampedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimestampedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n12, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Timestamp.Size()))
	n13, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *EpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Realm) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.Realm)))
		i += copy(data[i:], m.Realm)
	}
	if m.Epoch != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if m.RootHash != nil {
		if len(m.RootHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.RootHash)))
			i += copy(data[i:], m.RootHash)
		}
	}
	data[i] = 0x22
	i++
	i = encodeVarintClient(data, i, uint64(m.IssueTime.Size()))
	n14, err := m.IssueTime.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.PreviousSummaryHash != nil {
		if len(m.PreviousSummaryHash) > 0 {
			data[i] = 0x2a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.PreviousSummaryHash)))
			i += copy(data[i:], m.PreviousSummaryHash)
		}
	}
	data[i] = 0x32
	i++
	i = encodeVarintClient(data, i, uint64(m.NextEpochPolicy.Size()))
	n15, err := m.NextEpochPolicy.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *AuthorizationPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorizationPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		keysForPublicKeys := make([]uint64, 0, len(m.PublicKeys))
		for k, _ := range m.PublicKeys {
			keysForPublicKeys = append(keysForPublicKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
		for _, k := range keysForPublicKeys {
			data[i] = 0xa
			i++
			v := m.PublicKeys[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + 8 + 1 + msgSize + sovClient(uint64(msgSize))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(v.Size()))
			n16, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n16
		}
	}
	if m.PolicyType != nil {
		nn17, err := m.PolicyType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	return i, nil
}

func (m *AuthorizationPolicy_Quorum) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Quorum != nil {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(m.Quorum.Size()))
		n18, err := m.Quorum.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *PublicKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PublicKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PubkeyType != nil {
		nn19, err := m.PubkeyType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	return i, nil
}

func (m *PublicKey_Ed25519) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Ed25519 != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.Ed25519)))
		i += copy(data[i:], m.Ed25519)
	}
	return i, nil
}
func (m *QuorumExpr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *QuorumExpr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		for _, num := range m.Candidates {
			data[i] = 0x11
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Subexpressions) > 0 {
		for _, msg := range m.Subexpressions {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EmailProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProofType != nil {
		nn20, err := m.ProofType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	return i, nil
}

func (m *EmailProof_DKIMProof) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.DKIMProof != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.DKIMProof)))
		i += copy(data[i:], m.DKIMProof)
	}
	return i, nil
}
func (m *EmailProof_OIDCToken) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(len(m.OIDCToken)))
	i += copy(data[i:], m.OIDCToken)
	return i, nil
}
func (m *EmailProof_SAMLResponse) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x1a
	i++
	i = encodeVarintClient(data, i, uint64(len(m.SAMLResponse)))
	i += copy(data[i:], m.SAMLResponse)
	return i, nil
}
func encodeFixed64Client(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Client(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintClient(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedLookupRequest(r randyClient, easy bool) *LookupRequest {
	this := &LookupRequest{}
	this.Epoch = uint64(uint64(r.Uint32()))
	this.UserId = randStringClient(r)
	if r.Intn(10) != 0 {
		this.QuorumRequirement = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateRequest(r randyClient, easy bool) *UpdateRequest {
	this := &UpdateRequest{}
	if r.Intn(10) != 0 {
		this.Update = NewPopulatedSignedEntryUpdate(r, easy)
	}
	v1 := NewPopulatedEncodedProfile(r, easy)
	this.Profile = *v1
	if r.Intn(10) != 0 {
		this.LookupParameters = NewPopulatedLookupRequest(r, easy)
	}
	if r.Intn(10) != 0 {
		this.EmailProof = NewPopulatedEmailProof(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLookupProof(r randyClient, easy bool) *LookupProof {
	this := &LookupProof{}
	this.UserId = randStringClient(r)
	v2 := r.Intn(100)
	this.Index = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	v3 := r.Intn(100)
	this.IndexProof = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.IndexProof[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Ratifications = make([]*SignedEpochHead, v4)
		for i := 0; i < v4; i++ {
			this.Ratifications[i] = NewPopulatedSignedEpochHead(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.TreeProof = NewPopulatedTreeProof(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Entry = NewPopulatedEncodedEntry(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Profile = NewPopulatedEncodedProfile(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTreeProof(r randyClient, easy bool) *TreeProof {
	this := &TreeProof{}
	v5 := r.Intn(100)
	this.Neighbors = make([][]byte, v5)
	for i := 0; i < v5; i++ {
		v6 := r.Intn(100)
		this.Neighbors[i] = make([]byte, v6)
		for j := 0; j < v6; j++ {
			this.Neighbors[i][j] = byte(r.Intn(256))
		}
	}
	v7 := r.Intn(100)
	this.ExistingIndex = make([]byte, v7)
	for i := 0; i < v7; i++ {
		this.ExistingIndex[i] = byte(r.Intn(256))
	}
	v8 := r.Intn(100)
	this.ExistingEntryHash = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.ExistingEntryHash[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEntry(r randyClient, easy bool) *Entry {
	this := &Entry{}
	v9 := r.Intn(100)
	this.Index = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	this.Version = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.UpdatePolicy = NewPopulatedAuthorizationPolicy(r, easy)
	}
	v10 := r.Intn(100)
	this.ProfileCommitment = make([]byte, v10)
	for i := 0; i < v10; i++ {
		this.ProfileCommitment[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEntryUpdate(r randyClient, easy bool) *SignedEntryUpdate {
	this := &SignedEntryUpdate{}
	v11 := NewPopulatedEncodedEntry(r, easy)
	this.NewEntry = *v11
	if r.Intn(10) != 0 {
		v12 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v12; i++ {
			v13 := r.Intn(100)
			v14 := uint64(uint64(r.Uint32()))
			this.Signatures[v14] = make([]byte, v13)
			for i := 0; i < v13; i++ {
				this.Signatures[v14][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProfile(r randyClient, easy bool) *Profile {
	this := &Profile{}
	v15 := r.Intn(100)
	this.Nonce = make([]byte, v15)
	for i := 0; i < v15; i++ {
		this.Nonce[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v16 := r.Intn(10)
		this.Keys = make(map[string][]byte)
		for i := 0; i < v16; i++ {
			v17 := r.Intn(100)
			v18 := randStringClient(r)
			this.Keys[v18] = make([]byte, v17)
			for i := 0; i < v17; i++ {
				this.Keys[v18][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEpochHead(r randyClient, easy bool) *SignedEpochHead {
	this := &SignedEpochHead{}
	v19 := NewPopulatedEncodedTimestampedEpochHead(r, easy)
	this.Head = *v19
	if r.Intn(10) != 0 {
		v20 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v20; i++ {
			v21 := r.Intn(100)
			v22 := uint64(uint64(r.Uint32()))
			this.Signatures[v22] = make([]byte, v21)
			for i := 0; i < v21; i++ {
				this.Signatures[v22][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimestampedEpochHead(r randyClient, easy bool) *TimestampedEpochHead {
	this := &TimestampedEpochHead{}
	v23 := NewPopulatedEncodedEpochHead(r, easy)
	this.Head = *v23
	v24 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v24
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEpochHead(r randyClient, easy bool) *EpochHead {
	this := &EpochHead{}
	this.Realm = randStringClient(r)
	this.Epoch = uint64(uint64(r.Uint32()))
	v25 := r.Intn(100)
	this.RootHash = make([]byte, v25)
	for i := 0; i < v25; i++ {
		this.RootHash[i] = byte(r.Intn(256))
	}
	v26 := NewPopulatedTimestamp(r, easy)
	this.IssueTime = *v26
	v27 := r.Intn(100)
	this.PreviousSummaryHash = make([]byte, v27)
	for i := 0; i < v27; i++ {
		this.PreviousSummaryHash[i] = byte(r.Intn(256))
	}
	v28 := NewPopulatedAuthorizationPolicy(r, easy)
	this.NextEpochPolicy = *v28
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy(r randyClient, easy bool) *AuthorizationPolicy {
	this := &AuthorizationPolicy{}
	if r.Intn(10) != 0 {
		v29 := r.Intn(10)
		this.PublicKeys = make(map[uint64]*PublicKey)
		for i := 0; i < v29; i++ {
			this.PublicKeys[uint64(uint64(r.Uint32()))] = NewPopulatedPublicKey(r, easy)
		}
	}
	oneofNumber_PolicyType := []int32{2}[r.Intn(1)]
	switch oneofNumber_PolicyType {
	case 2:
		this.PolicyType = NewPopulatedAuthorizationPolicy_Quorum(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy_Quorum(r randyClient, easy bool) *AuthorizationPolicy_Quorum {
	this := &AuthorizationPolicy_Quorum{}
	this.Quorum = NewPopulatedQuorumExpr(r, easy)
	return this
}
func NewPopulatedPublicKey(r randyClient, easy bool) *PublicKey {
	this := &PublicKey{}
	oneofNumber_PubkeyType := []int32{1}[r.Intn(1)]
	switch oneofNumber_PubkeyType {
	case 1:
		this.PubkeyType = NewPopulatedPublicKey_Ed25519(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPublicKey_Ed25519(r randyClient, easy bool) *PublicKey_Ed25519 {
	this := &PublicKey_Ed25519{}
	v30 := r.Intn(100)
	this.Ed25519 = make([]byte, v30)
	for i := 0; i < v30; i++ {
		this.Ed25519[i] = byte(r.Intn(256))
	}
	return this
}
func NewPopulatedQuorumExpr(r randyClient, easy bool) *QuorumExpr {
	this := &QuorumExpr{}
	this.Threshold = uint32(r.Uint32())
	v31 := r.Intn(100)
	this.Candidates = make([]uint64, v31)
	for i := 0; i < v31; i++ {
		this.Candidates[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(10) != 0 {
		v32 := r.Intn(2)
		this.Subexpressions = make([]*QuorumExpr, v32)
		for i := 0; i < v32; i++ {
			this.Subexpressions[i] = NewPopulatedQuorumExpr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmailProof(r randyClient, easy bool) *EmailProof {
	this := &EmailProof{}
	oneofNumber_ProofType := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_ProofType {
	case 1:
		this.ProofType = NewPopulatedEmailProof_DKIMProof(r, easy)
	case 2:
		this.ProofType = NewPopulatedEmailProof_OIDCToken(r, easy)
	case 3:
		this.ProofType = NewPopulatedEmailProof_SAMLResponse(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmailProof_DKIMProof(r randyClient, easy bool) *EmailProof_DKIMProof {
	this := &EmailProof_DKIMProof{}
	v33 := r.Intn(100)
	this.DKIMProof = make([]byte, v33)
	for i := 0; i < v33; i++ {
		this.DKIMProof[i] = byte(r.Intn(256))
	}
	return this
}
func NewPopulatedEmailProof_OIDCToken(r randyClient, easy bool) *EmailProof_OIDCToken {
	this := &EmailProof_OIDCToken{}
	this.OIDCToken = randStringClient(r)
	return this
}
func NewPopulatedEmailProof_SAMLResponse(r randyClient, easy bool) *EmailProof_SAMLResponse {
	this := &EmailProof_SAMLResponse{}
	this.SAMLResponse = randStringClient(r)
	return this
}

type randyClient interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneClient(r randyClient) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringClient(r randyClient) string {
	v34 := r.Intn(100)
	tmps := make([]rune, v34)
	for i := 0; i < v34; i++ {
		tmps[i] = randUTF8RuneClient(r)
	}
	return string(tmps)
}
func randUnrecognizedClient(r randyClient, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldClient(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldClient(data []byte, r randyClient, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateClient(data, uint64(key))
		v35 := r.Int63()
		if r.Intn(2) == 0 {
			v35 *= -1
		}
		data = encodeVarintPopulateClient(data, uint64(v35))
	case 1:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateClient(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateClient(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateClient(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.QuorumRequirement != nil {
		l = m.QuorumRequirement.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *UpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	l = m.Profile.Size()
	n += 1 + l + sovClient(uint64(l))
	if m.LookupParameters != nil {
		l = m.LookupParameters.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.EmailProof != nil {
		l = m.EmailProof.Size()
		n += 2 + l + sovClient(uint64(l))
	}
	return n
}

func (m *LookupProof) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.IndexProof != nil {
		l = len(m.IndexProof)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Ratifications) > 0 {
		for _, e := range m.Ratifications {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.TreeProof != nil {
		l = m.TreeProof.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *TreeProof) Size() (n int) {
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			l = len(b)
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingIndex != nil {
		l = len(m.ExistingIndex)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingEntryHash != nil {
		l = len(m.ExistingEntryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovClient(uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		l = m.UpdatePolicy.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.ProfileCommitment != nil {
		l = len(m.ProfileCommitment)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *SignedEntryUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.NewEntry.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Profile) Size() (n int) {
	var l int
	_ = l
	if m.Nonce != nil {
		l = len(m.Nonce)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Keys) > 0 {
		for k, v := range m.Keys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SignedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TimestampedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *EpochHead) Size() (n int) {
	var l int
	_ = l
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	if m.RootHash != nil {
		l = len(m.RootHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	l = m.IssueTime.Size()
	n += 1 + l + sovClient(uint64(l))
	if m.PreviousSummaryHash != nil {
		l = len(m.PreviousSummaryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	l = m.NextEpochPolicy.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *AuthorizationPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for k, v := range m.PublicKeys {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + 8 + 1 + l + sovClient(uint64(l))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	if m.PolicyType != nil {
		n += m.PolicyType.Size()
	}
	return n
}

func (m *AuthorizationPolicy_Quorum) Size() (n int) {
	var l int
	_ = l
	if m.Quorum != nil {
		l = m.Quorum.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}
func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	if m.PubkeyType != nil {
		n += m.PubkeyType.Size()
	}
	return n
}

func (m *PublicKey_Ed25519) Size() (n int) {
	var l int
	_ = l
	if m.Ed25519 != nil {
		l = len(m.Ed25519)
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}
func (m *QuorumExpr) Size() (n int) {
	var l int
	_ = l
	if m.Threshold != 0 {
		n += 1 + sovClient(uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		n += 9 * len(m.Candidates)
	}
	if len(m.Subexpressions) > 0 {
		for _, e := range m.Subexpressions {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *EmailProof) Size() (n int) {
	var l int
	_ = l
	if m.ProofType != nil {
		n += m.ProofType.Size()
	}
	return n
}

func (m *EmailProof_DKIMProof) Size() (n int) {
	var l int
	_ = l
	if m.DKIMProof != nil {
		l = len(m.DKIMProof)
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}
func (m *EmailProof_OIDCToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.OIDCToken)
	n += 1 + l + sovClient(uint64(l))
	return n
}
func (m *EmailProof_SAMLResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.SAMLResponse)
	n += 1 + l + sovClient(uint64(l))
	return n
}

func sovClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClient(x uint64) (n int) {
	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LookupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupRequest{`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`QuorumRequirement:` + strings.Replace(fmt.Sprintf("%v", this.QuorumRequirement), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateRequest{`,
		`Update:` + strings.Replace(fmt.Sprintf("%v", this.Update), "SignedEntryUpdate", "SignedEntryUpdate", 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`LookupParameters:` + strings.Replace(fmt.Sprintf("%v", this.LookupParameters), "LookupRequest", "LookupRequest", 1) + `,`,
		`EmailProof:` + strings.Replace(fmt.Sprintf("%v", this.EmailProof), "EmailProof", "EmailProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookupProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupProof{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`IndexProof:` + fmt.Sprintf("%v", this.IndexProof) + `,`,
		`Ratifications:` + strings.Replace(fmt.Sprintf("%v", this.Ratifications), "SignedEpochHead", "SignedEpochHead", 1) + `,`,
		`TreeProof:` + strings.Replace(fmt.Sprintf("%v", this.TreeProof), "TreeProof", "TreeProof", 1) + `,`,
		`Entry:` + strings.Replace(fmt.Sprintf("%v", this.Entry), "Entry", "Entry", 1) + `,`,
		`Profile:` + strings.Replace(fmt.Sprintf("%v", this.Profile), "Profile", "Profile", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeProof{`,
		`Neighbors:` + fmt.Sprintf("%v", this.Neighbors) + `,`,
		`ExistingIndex:` + fmt.Sprintf("%v", this.ExistingIndex) + `,`,
		`ExistingEntryHash:` + fmt.Sprintf("%v", this.ExistingEntryHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`UpdatePolicy:` + strings.Replace(fmt.Sprintf("%v", this.UpdatePolicy), "AuthorizationPolicy", "AuthorizationPolicy", 1) + `,`,
		`ProfileCommitment:` + fmt.Sprintf("%v", this.ProfileCommitment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEntryUpdate) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEntryUpdate{`,
		`NewEntry:` + strings.Replace(strings.Replace(this.NewEntry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *Profile) String() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%v: %v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&Profile{`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`Keys:` + mapStringForKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "TimestampedEpochHead", "TimestampedEpochHead", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimestampedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimestampedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "EpochHead", "EpochHead", 1), `&`, ``, 1) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(this.Timestamp.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EpochHead{`,
		`Realm:` + fmt.Sprintf("%v", this.Realm) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`RootHash:` + fmt.Sprintf("%v", this.RootHash) + `,`,
		`IssueTime:` + strings.Replace(strings.Replace(this.IssueTime.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`PreviousSummaryHash:` + fmt.Sprintf("%v", this.PreviousSummaryHash) + `,`,
		`NextEpochPolicy:` + strings.Replace(strings.Replace(this.NextEpochPolicy.String(), "AuthorizationPolicy", "AuthorizationPolicy", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy) String() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%v: %v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&AuthorizationPolicy{`,
		`PublicKeys:` + mapStringForPublicKeys + `,`,
		`PolicyType:` + fmt.Sprintf("%v", this.PolicyType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy_Quorum) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizationPolicy_Quorum{`,
		`Quorum:` + strings.Replace(fmt.Sprintf("%v", this.Quorum), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey{`,
		`PubkeyType:` + fmt.Sprintf("%v", this.PubkeyType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey_Ed25519) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey_Ed25519{`,
		`Ed25519:` + fmt.Sprintf("%v", this.Ed25519) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuorumExpr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuorumExpr{`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Candidates:` + fmt.Sprintf("%v", this.Candidates) + `,`,
		`Subexpressions:` + strings.Replace(fmt.Sprintf("%v", this.Subexpressions), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProof{`,
		`ProofType:` + fmt.Sprintf("%v", this.ProofType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProof_DKIMProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProof_DKIMProof{`,
		`DKIMProof:` + fmt.Sprintf("%v", this.DKIMProof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProof_OIDCToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProof_OIDCToken{`,
		`OIDCToken:` + fmt.Sprintf("%v", this.OIDCToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProof_SAMLResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProof_SAMLResponse{`,
		`SAMLResponse:` + fmt.Sprintf("%v", this.SAMLResponse) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClient(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumRequirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumRequirement == nil {
				m.QuorumRequirement = &QuorumExpr{}
			}
			if err := m.QuorumRequirement.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &SignedEntryUpdate{}
			}
			if err := m.Update.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupParameters == nil {
				m.LookupParameters = &LookupRequest{}
			}
			if err := m.LookupParameters.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmailProof == nil {
				m.EmailProof = &EmailProof{}
			}
			if err := m.EmailProof.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexProof = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratifications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ratifications = append(m.Ratifications, &SignedEpochHead{})
			if err := m.Ratifications[len(m.Ratifications)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeProof == nil {
				m.TreeProof = &TreeProof{}
			}
			if err := m.TreeProof.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &EncodedEntry{}
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &EncodedProfile{}
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, make([]byte, postIndex-iNdEx))
			copy(m.Neighbors[len(m.Neighbors)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingIndex = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingEntryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingEntryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePolicy == nil {
				m.UpdatePolicy = &AuthorizationPolicy{}
			}
			if err := m.UpdatePolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileCommitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileCommitment = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEntryUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEntryUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEntryUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthClient
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Keys == nil {
				m.Keys = make(map[string][]byte)
			}
			m.Keys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimestampedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimestampedEpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimestampedEpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssueTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IssueTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousSummaryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousSummaryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextEpochPolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthClient
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthClient
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &PublicKey{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.PublicKeys == nil {
				m.PublicKeys = make(map[uint64]*PublicKey)
			}
			m.PublicKeys[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QuorumExpr{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &AuthorizationPolicy_Quorum{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ed25519", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, data[iNdEx:postIndex])
			m.PubkeyType = &PublicKey_Ed25519{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumExpr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidates", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Candidates = append(m.Candidates, v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subexpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subexpressions = append(m.Subexpressions, &QuorumExpr{})
			if err := m.Subexpressions[len(m.Subexpressions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DKIMProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, data[iNdEx:postIndex])
			m.ProofType = &EmailProof_DKIMProof{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofType = &EmailProof_OIDCToken{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLResponse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofType = &EmailProof_SAMLResponse{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClient(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClient(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClient   = fmt.Errorf("proto: integer overflow")
)
