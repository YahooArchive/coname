// Code generated by protoc-gen-gogo.
// source: client.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		client.proto
		config.proto
		duration.proto
		keyserverconfig.proto
		keyserverlocal.proto
		replication.proto
		timestamp.proto
		tlsconfig.proto
		verifierconfig.proto
		verifierlocal.proto
		verifier.proto

	It has these top-level messages:
		LookupRequest
		UpdateRequest
		LookupProof
		TreeProof
		Entry
		SignedEntryUpdate
		Profile
		SignedEpochHead
		TimestampedEpochHead
		EpochHead
		AuthorizationPolicy
		PublicKey
		QuorumExpr
		Config
		RealmConfig
		Duration
		ReplicaConfig
		KeyserverConfig
		Replica
		ReplicaState
		KeyserverStep
		EpochDelimiter
		Timestamp
		TLSConfig
		CertificateAndKeyID
		VerifierConfig
		VerifierState
		VerifierStreamRequest
		VerifierStep
		Nothing
*/
package proto

import proto1 "github.com/andres-erbsen/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "gogoproto"

import bytes "bytes"

import strings "strings"
import github_com_andres_erbsen_protobuf_proto "github.com/andres-erbsen/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"
import github_com_andres_erbsen_protobuf_sortkeys "github.com/andres-erbsen/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LookupRequest struct {
	// Epoch as of which to perform the lookup ("latest" if not specified)
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// UserId will be mapped to an index by the server using VRF
	UserId string `protobuf:"bytes,2,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// quorum_requirement specifies which verifiers must have ratified the
	// result for it to be accepted. A server would fall back to an older
	// directory state if the ratifications of the latest one do not satisfy
	// the quorum requirement.
	QuorumRequirement *QuorumExpr `protobuf:"bytes,4,opt,name=quorum_requirement" json:"quorum_requirement,omitempty"`
}

func (m *LookupRequest) Reset()      { *m = LookupRequest{} }
func (*LookupRequest) ProtoMessage() {}

func (m *LookupRequest) GetQuorumRequirement() *QuorumExpr {
	if m != nil {
		return m.QuorumRequirement
	}
	return nil
}

// UpdateRequest specifies an update and the quorum required for
// considering the update successful. The server should respond with a lookup
// of the updated name with the specified parameters.
type UpdateRequest struct {
	// Update is passed on to verifiers.
	Update *SignedEntryUpdate `protobuf:"bytes,1,opt,name=update" json:"update,omitempty"`
	// Profile is included in the update request from the client to the
	// keyserver, but not passed on to the verifiers. The keyserver SHOULD
	// store it locally and include it in LookupProofs returned for lookups.
	// The verifiers MUST NOT try to read this field.
	// A keyserver MUST NOT discriminate users based on ther structure of their
	// profile other than enforcing a common-sense size limit. In particular, a
	// profile with fields that the keyserver does not understand or whose
	// values it considers invalid MUST be accepted.
	Profile          EncodedProfile `protobuf:"bytes,2,opt,name=profile,customtype=EncodedProfile" json:"profile"`
	LookupParameters *LookupRequest `protobuf:"bytes,3,opt,name=lookup_parameters" json:"lookup_parameters,omitempty"`
	DKIMProof        []byte         `protobuf:"bytes,1000,opt,name=dkim_proof,proto3" json:"dkim_proof,omitempty"`
}

func (m *UpdateRequest) Reset()      { *m = UpdateRequest{} }
func (*UpdateRequest) ProtoMessage() {}

func (m *UpdateRequest) GetUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateRequest) GetLookupParameters() *LookupRequest {
	if m != nil {
		return m.LookupParameters
	}
	return nil
}

// LookupProof encapsulates end-to-end cryptographc evidence that assuming *at
// least one* of the ratifiers has been correctly following the rules of the
// keyserver protocol then profile contains the latest public keys and metadata
// uploaded by user_id before the time specified in ratifications[0]. If any
// step of the proof does not check out, the contents of profile MUST NOT be
// used for any other purpose than debugging.
type LookupProof struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,proto3" json:"user_id,omitempty"`
	Index  []byte `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	// index_proof proves that index is a result of applying a globally fixed
	// bijection VRF to user_id: idx = VRF(user_ID). If this proof checks out,
	// we can safely continue by looking up the keyserver entry corresponding
	// to index to get the public key of user_id.
	IndexProof []byte `protobuf:"bytes,3,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// ratifications contains signed directory state summaries for the epoch under
	// which the lookup was performed.
	// A single valid ratification r by a honest and correct verifier implies
	// that the r.ratification.summary.root_hash summarizes the authenticated
	// data structure containing the unique and correct mapping from indices to
	// entries as of epoch r.ratification.epoch at human time
	// r.ratification.timestamp.
	// Each ratification must contain the same epoch head. A client MUST ignore a
	// proof if the ratifications do not satisfy its quorum requirement and MUST
	// require the keyserver itself to be in the quorum.
	Ratifications []*SignedEpochHead `protobuf:"bytes,4,rep,name=ratifications" json:"ratifications,omitempty"`
	// tree_proof contains an authenticated data structure lookup trace,
	// arguing that index maps to entry in the data structure with hash
	// ratifications[0].ratification.summary.root_hash.
	TreeProof *TreeProof `protobuf:"bytes,5,opt,name=tree_proof" json:"tree_proof,omitempty"`
	// Entry specifies profile by hash(profile) = entry.profile_hash
	Entry   *EncodedEntry   `protobuf:"bytes,6,opt,name=entry,customtype=EncodedEntry" json:"entry,omitempty"`
	Profile *EncodedProfile `protobuf:"bytes,7,opt,name=profile,customtype=EncodedProfile" json:"profile,omitempty"`
}

func (m *LookupProof) Reset()      { *m = LookupProof{} }
func (*LookupProof) ProtoMessage() {}

func (m *LookupProof) GetRatifications() []*SignedEpochHead {
	if m != nil {
		return m.Ratifications
	}
	return nil
}

func (m *LookupProof) GetTreeProof() *TreeProof {
	if m != nil {
		return m.TreeProof
	}
	return nil
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is or is not present in the tree.
type TreeProof struct {
	// Neighbors is a list of all the adjacent nodes along the path from the
	// bottommost node to the root. To save space, hashes for empty subtrees are
	// nil, and the number of hashes is equal to the length of the longest common
	// prefix with another entry in the tree (since a leaf node is moved up to
	// that point -- subtrees with a single entry are coalesced into a single
	// node).
	Neighbors [][]byte `protobuf:"bytes,1,rep,name=neighbors" json:"neighbors,omitempty"`
	// This is the index for the binding that does exist; it will share a prefix
	// with the requested index, but in case the leaf contains the wrong
	// contents, it will be different. It will be nil if the requested VRF falls
	// under an empty branch.
	ExistingIndex []byte `protobuf:"bytes,2,opt,name=existing_index,proto3" json:"existing_index,omitempty"`
	// This is the hash of the entry for the binding that does exist. If the leaf
	// contains the wrong contents, the client can use this to verify that the
	// incorrect leaf takes up the entire branch.
	ExistingEntryHash []byte `protobuf:"bytes,3,opt,name=existing_entry_hash,proto3" json:"existing_entry_hash,omitempty"`
}

func (m *TreeProof) Reset()      { *m = TreeProof{} }
func (*TreeProof) ProtoMessage() {}

// Entry is the value type in the authenticated mapping data structure.  The
// contents of all entries should be considered public (they are served to
// verifiers).
type Entry struct {
	// Index specifies the location of the entry in the authenticated
	// mapping data structure. It is computed as a verifiable random
	// function of the name: the keyserver can prove that index=vrf(name)
	// to anybody, but nobody else can compute vrf(name1). This is to
	// maintain the privacy of usernames.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// Version starts at 0 at registration and must not decrease. The keyserver
	// and verifiers MUST reject SignedEntryUpdates which violate these rules.
	// The purpose of this is to prevent an attacker from replaying a
	// SignedEntryUpdate that publishes a key that the attacker has gained
	// control of. On the other hand, increases by more than one are allowed: a
	// user should be allowed to generate a long-lived offline revocation
	// certificate that is valid even after they make some other change to
	// their profile. Nevertheless, unless explicitly required otherwise,
	// clients should increase the version number by exactly one on each
	// update.
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// UpdatePolicy will be used to verify SignedEntryUpdates to this
	// entry. It is NOT used for encryption, and SHOULD be ignored by
	// applications that do not intend to manage the user's profile. It has
	// also been called "the public key of the profile signing key" or "the
	// public identity key". A keyserver MUST NOT discriminate users based on
	// ther structure of their update_key other than (1) as specified in
	// SignedEntryUpdate and (2) common-sense limits on the total size of an
	// entry to limit storage cost.
	UpdatePolicy *AuthorizationPolicy `protobuf:"bytes,3,opt,name=update_policy" json:"update_policy,omitempty"`
	// ProfileCommitment uniquely specifies the profile without revealing its
	// contents. The commitment is computed as commitment =
	// sha3shake256(profile); the contents contain a nonce.
	ProfileCommitment []byte `protobuf:"bytes,4,opt,name=profile_commitment,proto3" json:"profile_commitment,omitempty"`
}

func (m *Entry) Reset()      { *m = Entry{} }
func (*Entry) ProtoMessage() {}

func (m *Entry) GetUpdatePolicy() *AuthorizationPolicy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

// SignedEntryUpdate is the minimal self-contained structure to justify
// changing the value of an entry. In the state machine model of a namespace,
// SignedEntryUpdate is the main input type.
type SignedEntryUpdate struct {
	NewEntry EncodedEntry `protobuf:"bytes,1,opt,name=new_entry,customtype=EncodedEntry" json:"new_entry"`
	// NewSig, if successfully verified using update.new_entry.update_key,
	// confirms that the new entry is willing to be bound to this index.
	// Both the keyserver and verifiers MUST check these signatures against the
	// old profile's authorization policy AND the new profile's authorization
	// policy. All signatures are tagged with ID of the public key that
	// generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()      { *m = SignedEntryUpdate{} }
func (*SignedEntryUpdate) ProtoMessage() {}

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// A user's profile, containing public keys and other information.
// A new field will be added here for each application, with the TCP/UDP port
// number as field number whenever possible to avoid collisions.
type Profile struct {
	// Nonce containst at least 16 bytes (and counts towards the total profile
	// size limit). Having a nonce in each profile ensures that an attacker
	// can't guess-and-check somebody's profile contents using Entry.profile_hash.
	// It is the client's responsibility to generate a random nonce to protect the
	// privacy of its profile, thus the presence of this field is not checked by
	// the server.
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Application-specific public keys. The map is keyed by application ID.
	Keys map[string][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()      { *m = Profile{} }
func (*Profile) ProtoMessage() {}

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// SignedEpochHead messages are used by auditors and the service provider to
// vouch that the SummaryHash represents the correct unique global state at the
// end of epoch. In particular, it means that the signer has enforced the
// profile update policy specified in the doc-comments of SignedEntryUpdate and
// Profile for the specified epoch AND all prior epochs. A Ratification MUST
// NOT be signed in any other circumstances.
type SignedEpochHead struct {
	Head EncodedTimestampedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedTimestampedEpochHead" json:"head"`
	// Signatures is used for authentication of ratification and MUST be
	// verified before interpreting any contents of ratification.
	// All signatures are tagged with ID of the public key that generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()      { *m = SignedEpochHead{} }
func (*SignedEpochHead) ProtoMessage() {}

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type TimestampedEpochHead struct {
	// EpochHead specifies the entire state and history of the
	// realm.
	Head EncodedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedEpochHead" json:"head"`
	// Timestamp specifies when the requirements for SignedEpochHead
	// were checked. Clients will accept a SignedEpochHead timestamped at most a
	// fixed amount of time into the past, and MUST fail secure if the timestamp
	// is not fresh because the directory state may have changed. The signature
	// expiration tolerance plus the maximum clock skew between a pair of clients
	// is the maximum propogation time of a change from one to another after which
	// even a malicious keyserver will not be able to convince a client to a
	// accept the previous state (assuming that all quorums the client considers
	// sufficient contain a correct and honest server).
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *TimestampedEpochHead) Reset()      { *m = TimestampedEpochHead{} }
func (*TimestampedEpochHead) ProtoMessage() {}

func (m *TimestampedEpochHead) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

type EpochHead struct {
	// Realm is the fully-qualified domain name of the keyserver whose
	// state is being ratified.
	Realm string `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty"`
	// Epoch is a sequence number tracking distinct ratified states.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// RootHash specifies the authenticated data structure.
	RootHash []byte `protobuf:"bytes,3,opt,name=root_hash,proto3" json:"root_hash,omitempty"`
	// IssueTime is the time when this epoch was released. All epochs for the
	// same keyserver MUST have non-decreasing IssueTimes.
	IssueTime Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time"`
	// PreviousSummaryHash chaining is used to allow signatures from
	// different epochs in the same quorum: a signature vouches for all
	// epochs chained to that in addition to the one listed.
	// Each PreviousSummaryHash depends on PreviousSummary, therefore
	// (by induction on the hash-pointer structure) a
	// PreviousSummeryHash for some epoch specifies the states of all
	// previous epochs. This hash uses SHA3-SHAKE256 with 64 bytes of output.
	PreviousSummaryHash []byte `protobuf:"bytes,5,opt,name=previous_summary_hash,proto3" json:"previous_summary_hash,omitempty"`
	// NextEpochPolicy allows for automated server key rollover: the new key(s)
	// are signed by the current one as a part of the epoch. This field is nil
	// if no key change is requested. If the server key is distributed with the
	// client software and benefits from reliable automated updates, clients
	// MAY ignore this field.
	NextEpochPolicy AuthorizationPolicy `protobuf:"bytes,6,opt,name=next_epoch_policy" json:"next_epoch_policy"`
}

func (m *EpochHead) Reset()      { *m = EpochHead{} }
func (*EpochHead) ProtoMessage() {}

func (m *EpochHead) GetIssueTime() Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return Timestamp{}
}

func (m *EpochHead) GetNextEpochPolicy() AuthorizationPolicy {
	if m != nil {
		return m.NextEpochPolicy
	}
	return AuthorizationPolicy{}
}

// AuthorizationPolicy is used to check whether some signatures make up
// sufficient authorization to back an action.
// This is used to implement the following:
// 1. Account Recovery through service provider: if an user's entry has the
// update key set to threshold(1,user,serviceprovider), the service
// provider can perform account recovery. Note that a third party will not
// necessarily know who the subkeys are held by. Thus, the client
// implementation MUST require a signed certificate confirming possession
// of the secret key and promising to do no evil from every trustee whose
// key is used for recovery in this manner.
// 2. Service providers with servers in geographically diverse locations
// can use a threshold to limit the damage the compromise or loss of one
// replica can do. Example threshold(2,freedonia,gilead,mordor).
// 3. Adaptive key rollover during cryptocalypse.
type AuthorizationPolicy struct {
	PublicKeys map[uint64]*PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Types that are valid to be assigned to PolicyType:
	//	*AuthorizationPolicy_Quorum
	PolicyType isAuthorizationPolicy_PolicyType `protobuf_oneof:"policy_type"`
}

func (m *AuthorizationPolicy) Reset()      { *m = AuthorizationPolicy{} }
func (*AuthorizationPolicy) ProtoMessage() {}

type isAuthorizationPolicy_PolicyType interface {
	isAuthorizationPolicy_PolicyType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthorizationPolicy_Quorum struct {
	Quorum *QuorumExpr `protobuf:"bytes,2,opt,name=quorum,oneof"`
}

func (*AuthorizationPolicy_Quorum) isAuthorizationPolicy_PolicyType() {}

func (m *AuthorizationPolicy) GetPolicyType() isAuthorizationPolicy_PolicyType {
	if m != nil {
		return m.PolicyType
	}
	return nil
}

func (m *AuthorizationPolicy) GetPublicKeys() map[uint64]*PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *AuthorizationPolicy) GetQuorum() *QuorumExpr {
	if x, ok := m.GetPolicyType().(*AuthorizationPolicy_Quorum); ok {
		return x.Quorum
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AuthorizationPolicy) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _AuthorizationPolicy_OneofMarshaler, _AuthorizationPolicy_OneofUnmarshaler, []interface{}{
		(*AuthorizationPolicy_Quorum)(nil),
	}
}

func _AuthorizationPolicy_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*AuthorizationPolicy)
	// policy_type
	switch x := m.PolicyType.(type) {
	case *AuthorizationPolicy_Quorum:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Quorum); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AuthorizationPolicy.PolicyType has unexpected type %T", x)
	}
	return nil
}

func _AuthorizationPolicy_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*AuthorizationPolicy)
	switch tag {
	case 2: // policy_type.quorum
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(QuorumExpr)
		err := b.DecodeMessage(msg)
		m.PolicyType = &AuthorizationPolicy_Quorum{msg}
		return true, err
	default:
		return false, nil
	}
}

// PublicKey wraps a public key of a cryptographically secure signature
// scheme and verification metadata. Each verifier can have its own signature
// format and needs to implement serialization and deserialization of its own
// signatures. The ID of a public key is defined as the 64-bit SHAKE256 hash of
// the protobuf-encoded public key (and interpreted as little-endian when a
// numeric representation is required).
type PublicKey struct {
	// Types that are valid to be assigned to PubkeyType:
	//	*PublicKey_Ed25519
	PubkeyType isPublicKey_PubkeyType `protobuf_oneof:"pubkey_type"`
}

func (m *PublicKey) Reset()      { *m = PublicKey{} }
func (*PublicKey) ProtoMessage() {}

type isPublicKey_PubkeyType interface {
	isPublicKey_PubkeyType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type PublicKey_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3,oneof"`
}

func (*PublicKey_Ed25519) isPublicKey_PubkeyType() {}

func (m *PublicKey) GetPubkeyType() isPublicKey_PubkeyType {
	if m != nil {
		return m.PubkeyType
	}
	return nil
}

func (m *PublicKey) GetEd25519() []byte {
	if x, ok := m.GetPubkeyType().(*PublicKey_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PublicKey) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _PublicKey_OneofMarshaler, _PublicKey_OneofUnmarshaler, []interface{}{
		(*PublicKey_Ed25519)(nil),
	}
}

func _PublicKey_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*PublicKey)
	// pubkey_type
	switch x := m.PubkeyType.(type) {
	case *PublicKey_Ed25519:
		_ = b.EncodeVarint(1<<3 | proto1.WireBytes)
		_ = b.EncodeRawBytes(x.Ed25519)
	case nil:
	default:
		return fmt.Errorf("PublicKey.PubkeyType has unexpected type %T", x)
	}
	return nil
}

func _PublicKey_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*PublicKey)
	switch tag {
	case 1: // pubkey_type.ed25519
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.PubkeyType = &PublicKey_Ed25519{x}
		return true, err
	default:
		return false, nil
	}
}

// QuorumExpr represents a function with type set<uint64> -> bool. An
// expression evaluates to true given args iff the sum of the following two
// numbers is at least threshold:
// - number of entries in verifiers that are in args
// - number of subexpressions that evaluate to true
// note: expr.eval(a) \wedge expr.eval(b) -> expr.eval(a \cup b)
type QuorumExpr struct {
	Threshold  uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Candidates []uint64 `protobuf:"fixed64,2,rep,name=candidates" json:"candidates,omitempty"`
	// QuorumExpr allows expressing contitions of the form "two out of these
	// and three out of those".
	// If an implementation chooses to ban recursive thresholding, it can do so
	// ignoring this field. However, doing so is NOT SUPPORTED.
	Subexpressions []*QuorumExpr `protobuf:"bytes,3,rep,name=subexpressions" json:"subexpressions,omitempty"`
}

func (m *QuorumExpr) Reset()      { *m = QuorumExpr{} }
func (*QuorumExpr) ProtoMessage() {}

func (m *QuorumExpr) GetSubexpressions() []*QuorumExpr {
	if m != nil {
		return m.Subexpressions
	}
	return nil
}

func (this *LookupRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return fmt.Errorf("that is not of type *LookupRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupRequestbut is not nil && this == nil")
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return fmt.Errorf("QuorumRequirement this(%v) Not Equal that(%v)", this.QuorumRequirement, that1.QuorumRequirement)
	}
	return nil
}
func (this *LookupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return false
	}
	return true
}
func (this *UpdateRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return fmt.Errorf("that is not of type *UpdateRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateRequestbut is not nil && this == nil")
	}
	if !this.Update.Equal(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", this.Update, that1.Update)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return fmt.Errorf("LookupParameters this(%v) Not Equal that(%v)", this.LookupParameters, that1.LookupParameters)
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return fmt.Errorf("DKIMProof this(%v) Not Equal that(%v)", this.DKIMProof, that1.DKIMProof)
	}
	return nil
}
func (this *UpdateRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return false
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return false
	}
	return true
}
func (this *LookupProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return fmt.Errorf("that is not of type *LookupProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupProofbut is not nil && this == nil")
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return fmt.Errorf("IndexProof this(%v) Not Equal that(%v)", this.IndexProof, that1.IndexProof)
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return fmt.Errorf("Ratifications this(%v) Not Equal that(%v)", len(this.Ratifications), len(that1.Ratifications))
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return fmt.Errorf("Ratifications this[%v](%v) Not Equal that[%v](%v)", i, this.Ratifications[i], i, that1.Ratifications[i])
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return fmt.Errorf("TreeProof this(%v) Not Equal that(%v)", this.TreeProof, that1.TreeProof)
	}
	if that1.Entry == nil {
		if this.Entry != nil {
			return fmt.Errorf("this.Entry != nil && that1.Entry == nil")
		}
	} else if !this.Entry.Equal(*that1.Entry) {
		return fmt.Errorf("Entry this(%v) Not Equal that(%v)", this.Entry, that1.Entry)
	}
	if that1.Profile == nil {
		if this.Profile != nil {
			return fmt.Errorf("this.Profile != nil && that1.Profile == nil")
		}
	} else if !this.Profile.Equal(*that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	return nil
}
func (this *LookupProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return false
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return false
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return false
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return false
	}
	if that1.Entry == nil {
		if this.Entry != nil {
			return false
		}
	} else if !this.Entry.Equal(*that1.Entry) {
		return false
	}
	if that1.Profile == nil {
		if this.Profile != nil {
			return false
		}
	} else if !this.Profile.Equal(*that1.Profile) {
		return false
	}
	return true
}
func (this *TreeProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return fmt.Errorf("that is not of type *TreeProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TreeProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TreeProofbut is not nil && this == nil")
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return fmt.Errorf("Neighbors this(%v) Not Equal that(%v)", len(this.Neighbors), len(that1.Neighbors))
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return fmt.Errorf("Neighbors this[%v](%v) Not Equal that[%v](%v)", i, this.Neighbors[i], i, that1.Neighbors[i])
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return fmt.Errorf("ExistingIndex this(%v) Not Equal that(%v)", this.ExistingIndex, that1.ExistingIndex)
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return fmt.Errorf("ExistingEntryHash this(%v) Not Equal that(%v)", this.ExistingEntryHash, that1.ExistingEntryHash)
	}
	return nil
}
func (this *TreeProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return false
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return false
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return false
	}
	return true
}
func (this *Entry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Entry)
	if !ok {
		return fmt.Errorf("that is not of type *Entry")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Entry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Entrybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return fmt.Errorf("UpdatePolicy this(%v) Not Equal that(%v)", this.UpdatePolicy, that1.UpdatePolicy)
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return fmt.Errorf("ProfileCommitment this(%v) Not Equal that(%v)", this.ProfileCommitment, that1.ProfileCommitment)
	}
	return nil
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Entry)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return false
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return false
	}
	return true
}
func (this *SignedEntryUpdate) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEntryUpdate")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEntryUpdate but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEntryUpdatebut is not nil && this == nil")
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return fmt.Errorf("NewEntry this(%v) Not Equal that(%v)", this.NewEntry, that1.NewEntry)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEntryUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *Profile) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Profile)
	if !ok {
		return fmt.Errorf("that is not of type *Profile")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Profile but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Profilebut is not nil && this == nil")
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if len(this.Keys) != len(that1.Keys) {
		return fmt.Errorf("Keys this(%v) Not Equal that(%v)", len(this.Keys), len(that1.Keys))
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return fmt.Errorf("Keys this[%v](%v) Not Equal that[%v](%v)", i, this.Keys[i], i, that1.Keys[i])
		}
	}
	return nil
}
func (this *Profile) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Profile)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *SignedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *TimestampedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *TimestampedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TimestampedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TimestampedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	return nil
}
func (this *TimestampedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *EpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *EpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EpochHeadbut is not nil && this == nil")
	}
	if this.Realm != that1.Realm {
		return fmt.Errorf("Realm this(%v) Not Equal that(%v)", this.Realm, that1.Realm)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return fmt.Errorf("RootHash this(%v) Not Equal that(%v)", this.RootHash, that1.RootHash)
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return fmt.Errorf("IssueTime this(%v) Not Equal that(%v)", this.IssueTime, that1.IssueTime)
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return fmt.Errorf("PreviousSummaryHash this(%v) Not Equal that(%v)", this.PreviousSummaryHash, that1.PreviousSummaryHash)
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return fmt.Errorf("NextEpochPolicy this(%v) Not Equal that(%v)", this.NextEpochPolicy, that1.NextEpochPolicy)
	}
	return nil
}
func (this *EpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Realm != that1.Realm {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return false
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return false
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return false
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicybut is not nil && this == nil")
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return fmt.Errorf("PublicKeys this(%v) Not Equal that(%v)", len(this.PublicKeys), len(that1.PublicKeys))
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return fmt.Errorf("PublicKeys this[%v](%v) Not Equal that[%v](%v)", i, this.PublicKeys[i], i, that1.PublicKeys[i])
		}
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return fmt.Errorf("this.PolicyType != nil && that1.PolicyType == nil")
		}
	} else if this.PolicyType == nil {
		return fmt.Errorf("this.PolicyType == nil && that1.PolicyType != nil")
	} else if err := this.PolicyType.VerboseEqual(that1.PolicyType); err != nil {
		return err
	}
	return nil
}
func (this *AuthorizationPolicy_Quorum) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy_Quorum)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy_Quorum")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy_Quorum but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicy_Quorumbut is not nil && this == nil")
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return fmt.Errorf("Quorum this(%v) Not Equal that(%v)", this.Quorum, that1.Quorum)
	}
	return nil
}
func (this *AuthorizationPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return false
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return false
		}
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return false
		}
	} else if this.PolicyType == nil {
		return false
	} else if !this.PolicyType.Equal(that1.PolicyType) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy_Quorum) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy_Quorum)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return false
	}
	return true
}
func (this *PublicKey) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKeybut is not nil && this == nil")
	}
	if that1.PubkeyType == nil {
		if this.PubkeyType != nil {
			return fmt.Errorf("this.PubkeyType != nil && that1.PubkeyType == nil")
		}
	} else if this.PubkeyType == nil {
		return fmt.Errorf("this.PubkeyType == nil && that1.PubkeyType != nil")
	} else if err := this.PubkeyType.VerboseEqual(that1.PubkeyType); err != nil {
		return err
	}
	return nil
}
func (this *PublicKey_Ed25519) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey_Ed25519)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey_Ed25519")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey_Ed25519 but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKey_Ed25519but is not nil && this == nil")
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return fmt.Errorf("Ed25519 this(%v) Not Equal that(%v)", this.Ed25519, that1.Ed25519)
	}
	return nil
}
func (this *PublicKey) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.PubkeyType == nil {
		if this.PubkeyType != nil {
			return false
		}
	} else if this.PubkeyType == nil {
		return false
	} else if !this.PubkeyType.Equal(that1.PubkeyType) {
		return false
	}
	return true
}
func (this *PublicKey_Ed25519) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey_Ed25519)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return false
	}
	return true
}
func (this *QuorumExpr) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return fmt.Errorf("that is not of type *QuorumExpr")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *QuorumExpr but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *QuorumExprbut is not nil && this == nil")
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return fmt.Errorf("Candidates this(%v) Not Equal that(%v)", len(this.Candidates), len(that1.Candidates))
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return fmt.Errorf("Candidates this[%v](%v) Not Equal that[%v](%v)", i, this.Candidates[i], i, that1.Candidates[i])
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return fmt.Errorf("Subexpressions this(%v) Not Equal that(%v)", len(this.Subexpressions), len(that1.Subexpressions))
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return fmt.Errorf("Subexpressions this[%v](%v) Not Equal that[%v](%v)", i, this.Subexpressions[i], i, that1.Subexpressions[i])
		}
	}
	return nil
}
func (this *QuorumExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return false
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return false
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return false
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return false
		}
	}
	return true
}
func (this *LookupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.LookupRequest{")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.QuorumRequirement != nil {
		s = append(s, "QuorumRequirement: "+fmt.Sprintf("%#v", this.QuorumRequirement)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.UpdateRequest{")
	if this.Update != nil {
		s = append(s, "Update: "+fmt.Sprintf("%#v", this.Update)+",\n")
	}
	s = append(s, "Profile: "+strings.Replace(this.Profile.GoString(), `&`, ``, 1)+",\n")
	if this.LookupParameters != nil {
		s = append(s, "LookupParameters: "+fmt.Sprintf("%#v", this.LookupParameters)+",\n")
	}
	s = append(s, "DKIMProof: "+fmt.Sprintf("%#v", this.DKIMProof)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LookupProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&proto.LookupProof{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "IndexProof: "+fmt.Sprintf("%#v", this.IndexProof)+",\n")
	if this.Ratifications != nil {
		s = append(s, "Ratifications: "+fmt.Sprintf("%#v", this.Ratifications)+",\n")
	}
	if this.TreeProof != nil {
		s = append(s, "TreeProof: "+fmt.Sprintf("%#v", this.TreeProof)+",\n")
	}
	if this.Entry != nil {
		s = append(s, "Entry: "+fmt.Sprintf("%#v", this.Entry)+",\n")
	}
	if this.Profile != nil {
		s = append(s, "Profile: "+fmt.Sprintf("%#v", this.Profile)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.TreeProof{")
	s = append(s, "Neighbors: "+fmt.Sprintf("%#v", this.Neighbors)+",\n")
	s = append(s, "ExistingIndex: "+fmt.Sprintf("%#v", this.ExistingIndex)+",\n")
	s = append(s, "ExistingEntryHash: "+fmt.Sprintf("%#v", this.ExistingEntryHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.Entry{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.UpdatePolicy != nil {
		s = append(s, "UpdatePolicy: "+fmt.Sprintf("%#v", this.UpdatePolicy)+",\n")
	}
	s = append(s, "ProfileCommitment: "+fmt.Sprintf("%#v", this.ProfileCommitment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedEntryUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.SignedEntryUpdate{")
	s = append(s, "NewEntry: "+strings.Replace(this.NewEntry.GoString(), `&`, ``, 1)+",\n")
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	if this.Signatures != nil {
		s = append(s, "Signatures: "+mapStringForSignatures+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Profile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.Profile{")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%#v: %#v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	if this.Keys != nil {
		s = append(s, "Keys: "+mapStringForKeys+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.SignedEpochHead{")
	s = append(s, "Head: "+strings.Replace(this.Head.GoString(), `&`, ``, 1)+",\n")
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	if this.Signatures != nil {
		s = append(s, "Signatures: "+mapStringForSignatures+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimestampedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.TimestampedEpochHead{")
	s = append(s, "Head: "+strings.Replace(this.Head.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Timestamp: "+strings.Replace(this.Timestamp.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto.EpochHead{")
	s = append(s, "Realm: "+fmt.Sprintf("%#v", this.Realm)+",\n")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "RootHash: "+fmt.Sprintf("%#v", this.RootHash)+",\n")
	s = append(s, "IssueTime: "+strings.Replace(this.IssueTime.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "PreviousSummaryHash: "+fmt.Sprintf("%#v", this.PreviousSummaryHash)+",\n")
	s = append(s, "NextEpochPolicy: "+strings.Replace(this.NextEpochPolicy.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.AuthorizationPolicy{")
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%#v: %#v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	if this.PublicKeys != nil {
		s = append(s, "PublicKeys: "+mapStringForPublicKeys+",\n")
	}
	if this.PolicyType != nil {
		s = append(s, "PolicyType: "+fmt.Sprintf("%#v", this.PolicyType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationPolicy_Quorum) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.AuthorizationPolicy_Quorum{` +
		`Quorum:` + fmt.Sprintf("%#v", this.Quorum) + `}`}, ", ")
	return s
}
func (this *PublicKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.PublicKey{")
	if this.PubkeyType != nil {
		s = append(s, "PubkeyType: "+fmt.Sprintf("%#v", this.PubkeyType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PublicKey_Ed25519) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.PublicKey_Ed25519{` +
		`Ed25519:` + fmt.Sprintf("%#v", this.Ed25519) + `}`}, ", ")
	return s
}
func (this *QuorumExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.QuorumExpr{")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "Candidates: "+fmt.Sprintf("%#v", this.Candidates)+",\n")
	if this.Subexpressions != nil {
		s = append(s, "Subexpressions: "+fmt.Sprintf("%#v", this.Subexpressions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringClient(e map[int32]github_com_andres_erbsen_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for E2EKSPublic service

type E2EKSPublicClient interface {
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error)
}

type e2EKSPublicClient struct {
	cc *grpc.ClientConn
}

func NewE2EKSPublicClient(cc *grpc.ClientConn) E2EKSPublicClient {
	return &e2EKSPublicClient{cc}
}

func (c *e2EKSPublicClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKSPublicClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKSPublic service

type E2EKSPublicServer interface {
	Lookup(context.Context, *LookupRequest) (*LookupProof, error)
	Update(context.Context, *UpdateRequest) (*LookupProof, error)
}

func RegisterE2EKSPublicServer(s *grpc.Server, srv E2EKSPublicServer) {
	s.RegisterService(&_E2EKSPublic_serviceDesc, srv)
}

func _E2EKSPublic_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSPublicServer).Lookup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKSPublic_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSPublicServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKSPublic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.E2EKSPublic",
	HandlerType: (*E2EKSPublicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _E2EKSPublic_Lookup_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _E2EKSPublic_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *LookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if len(m.UserId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.QuorumRequirement != nil {
		data[i] = 0x22
		i++
		i = encodeVarintClient(data, i, uint64(m.QuorumRequirement.Size()))
		n1, err := m.QuorumRequirement.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *UpdateRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(m.Update.Size()))
		n2, err := m.Update.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
	n3, err := m.Profile.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.LookupParameters != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.LookupParameters.Size()))
		n4, err := m.LookupParameters.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DKIMProof != nil {
		if len(m.DKIMProof) > 0 {
			data[i] = 0xc2
			i++
			data[i] = 0x3e
			i++
			i = encodeVarintClient(data, i, uint64(len(m.DKIMProof)))
			i += copy(data[i:], m.DKIMProof)
		}
	}
	return i, nil
}

func (m *LookupProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.IndexProof != nil {
		if len(m.IndexProof) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.IndexProof)))
			i += copy(data[i:], m.IndexProof)
		}
	}
	if len(m.Ratifications) > 0 {
		for _, msg := range m.Ratifications {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TreeProof != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintClient(data, i, uint64(m.TreeProof.Size()))
		n5, err := m.TreeProof.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Entry != nil {
		data[i] = 0x32
		i++
		i = encodeVarintClient(data, i, uint64(m.Entry.Size()))
		n6, err := m.Entry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Profile != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
		n7, err := m.Profile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TreeProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.ExistingIndex != nil {
		if len(m.ExistingIndex) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingIndex)))
			i += copy(data[i:], m.ExistingIndex)
		}
	}
	if m.ExistingEntryHash != nil {
		if len(m.ExistingEntryHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingEntryHash)))
			i += copy(data[i:], m.ExistingEntryHash)
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.UpdatePolicy.Size()))
		n8, err := m.UpdatePolicy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ProfileCommitment != nil {
		if len(m.ProfileCommitment) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ProfileCommitment)))
			i += copy(data[i:], m.ProfileCommitment)
		}
	}
	return i, nil
}

func (m *SignedEntryUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEntryUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.NewEntry.Size()))
	n9, err := m.NewEntry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Profile) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Profile) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nonce != nil {
		if len(m.Nonce) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Nonce)))
			i += copy(data[i:], m.Nonce)
		}
	}
	if len(m.Keys) > 0 {
		keysForKeys := make([]string, 0, len(m.Keys))
		for k, _ := range m.Keys {
			keysForKeys = append(keysForKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
		for _, k := range keysForKeys {
			data[i] = 0x12
			i++
			v := m.Keys[k]
			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *SignedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n10, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *TimestampedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimestampedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n11, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Timestamp.Size()))
	n12, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *EpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Realm) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.Realm)))
		i += copy(data[i:], m.Realm)
	}
	if m.Epoch != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if m.RootHash != nil {
		if len(m.RootHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.RootHash)))
			i += copy(data[i:], m.RootHash)
		}
	}
	data[i] = 0x22
	i++
	i = encodeVarintClient(data, i, uint64(m.IssueTime.Size()))
	n13, err := m.IssueTime.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.PreviousSummaryHash != nil {
		if len(m.PreviousSummaryHash) > 0 {
			data[i] = 0x2a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.PreviousSummaryHash)))
			i += copy(data[i:], m.PreviousSummaryHash)
		}
	}
	data[i] = 0x32
	i++
	i = encodeVarintClient(data, i, uint64(m.NextEpochPolicy.Size()))
	n14, err := m.NextEpochPolicy.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *AuthorizationPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorizationPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		keysForPublicKeys := make([]uint64, 0, len(m.PublicKeys))
		for k, _ := range m.PublicKeys {
			keysForPublicKeys = append(keysForPublicKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
		for _, k := range keysForPublicKeys {
			data[i] = 0xa
			i++
			v := m.PublicKeys[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + 8 + 1 + msgSize + sovClient(uint64(msgSize))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(v.Size()))
			n15, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n15
		}
	}
	if m.PolicyType != nil {
		nn16, err := m.PolicyType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *AuthorizationPolicy_Quorum) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Quorum != nil {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(m.Quorum.Size()))
		n17, err := m.Quorum.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *PublicKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PublicKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PubkeyType != nil {
		nn18, err := m.PubkeyType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	return i, nil
}

func (m *PublicKey_Ed25519) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Ed25519 != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.Ed25519)))
		i += copy(data[i:], m.Ed25519)
	}
	return i, nil
}
func (m *QuorumExpr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *QuorumExpr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		for _, num := range m.Candidates {
			data[i] = 0x11
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Subexpressions) > 0 {
		for _, msg := range m.Subexpressions {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Client(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Client(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintClient(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedLookupRequest(r randyClient, easy bool) *LookupRequest {
	this := &LookupRequest{}
	this.Epoch = uint64(uint64(r.Uint32()))
	this.UserId = randStringClient(r)
	if r.Intn(10) != 0 {
		this.QuorumRequirement = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateRequest(r randyClient, easy bool) *UpdateRequest {
	this := &UpdateRequest{}
	if r.Intn(10) != 0 {
		this.Update = NewPopulatedSignedEntryUpdate(r, easy)
	}
	v1 := NewPopulatedEncodedProfile(r, easy)
	this.Profile = *v1
	if r.Intn(10) != 0 {
		this.LookupParameters = NewPopulatedLookupRequest(r, easy)
	}
	v2 := r.Intn(100)
	this.DKIMProof = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.DKIMProof[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLookupProof(r randyClient, easy bool) *LookupProof {
	this := &LookupProof{}
	this.UserId = randStringClient(r)
	v3 := r.Intn(100)
	this.Index = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	v4 := r.Intn(100)
	this.IndexProof = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.IndexProof[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Ratifications = make([]*SignedEpochHead, v5)
		for i := 0; i < v5; i++ {
			this.Ratifications[i] = NewPopulatedSignedEpochHead(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.TreeProof = NewPopulatedTreeProof(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Entry = NewPopulatedEncodedEntry(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Profile = NewPopulatedEncodedProfile(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTreeProof(r randyClient, easy bool) *TreeProof {
	this := &TreeProof{}
	v6 := r.Intn(100)
	this.Neighbors = make([][]byte, v6)
	for i := 0; i < v6; i++ {
		v7 := r.Intn(100)
		this.Neighbors[i] = make([]byte, v7)
		for j := 0; j < v7; j++ {
			this.Neighbors[i][j] = byte(r.Intn(256))
		}
	}
	v8 := r.Intn(100)
	this.ExistingIndex = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.ExistingIndex[i] = byte(r.Intn(256))
	}
	v9 := r.Intn(100)
	this.ExistingEntryHash = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.ExistingEntryHash[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEntry(r randyClient, easy bool) *Entry {
	this := &Entry{}
	v10 := r.Intn(100)
	this.Index = make([]byte, v10)
	for i := 0; i < v10; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	this.Version = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.UpdatePolicy = NewPopulatedAuthorizationPolicy(r, easy)
	}
	v11 := r.Intn(100)
	this.ProfileCommitment = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.ProfileCommitment[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEntryUpdate(r randyClient, easy bool) *SignedEntryUpdate {
	this := &SignedEntryUpdate{}
	v12 := NewPopulatedEncodedEntry(r, easy)
	this.NewEntry = *v12
	if r.Intn(10) != 0 {
		v13 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v13; i++ {
			v14 := r.Intn(100)
			v15 := uint64(uint64(r.Uint32()))
			this.Signatures[v15] = make([]byte, v14)
			for i := 0; i < v14; i++ {
				this.Signatures[v15][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProfile(r randyClient, easy bool) *Profile {
	this := &Profile{}
	v16 := r.Intn(100)
	this.Nonce = make([]byte, v16)
	for i := 0; i < v16; i++ {
		this.Nonce[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(10)
		this.Keys = make(map[string][]byte)
		for i := 0; i < v17; i++ {
			v18 := r.Intn(100)
			v19 := randStringClient(r)
			this.Keys[v19] = make([]byte, v18)
			for i := 0; i < v18; i++ {
				this.Keys[v19][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEpochHead(r randyClient, easy bool) *SignedEpochHead {
	this := &SignedEpochHead{}
	v20 := NewPopulatedEncodedTimestampedEpochHead(r, easy)
	this.Head = *v20
	if r.Intn(10) != 0 {
		v21 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v21; i++ {
			v22 := r.Intn(100)
			v23 := uint64(uint64(r.Uint32()))
			this.Signatures[v23] = make([]byte, v22)
			for i := 0; i < v22; i++ {
				this.Signatures[v23][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimestampedEpochHead(r randyClient, easy bool) *TimestampedEpochHead {
	this := &TimestampedEpochHead{}
	v24 := NewPopulatedEncodedEpochHead(r, easy)
	this.Head = *v24
	v25 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v25
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEpochHead(r randyClient, easy bool) *EpochHead {
	this := &EpochHead{}
	this.Realm = randStringClient(r)
	this.Epoch = uint64(uint64(r.Uint32()))
	v26 := r.Intn(100)
	this.RootHash = make([]byte, v26)
	for i := 0; i < v26; i++ {
		this.RootHash[i] = byte(r.Intn(256))
	}
	v27 := NewPopulatedTimestamp(r, easy)
	this.IssueTime = *v27
	v28 := r.Intn(100)
	this.PreviousSummaryHash = make([]byte, v28)
	for i := 0; i < v28; i++ {
		this.PreviousSummaryHash[i] = byte(r.Intn(256))
	}
	v29 := NewPopulatedAuthorizationPolicy(r, easy)
	this.NextEpochPolicy = *v29
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy(r randyClient, easy bool) *AuthorizationPolicy {
	this := &AuthorizationPolicy{}
	if r.Intn(10) != 0 {
		v30 := r.Intn(10)
		this.PublicKeys = make(map[uint64]*PublicKey)
		for i := 0; i < v30; i++ {
			this.PublicKeys[uint64(uint64(r.Uint32()))] = NewPopulatedPublicKey(r, easy)
		}
	}
	oneofNumber_PolicyType := []int32{2}[r.Intn(1)]
	switch oneofNumber_PolicyType {
	case 2:
		this.PolicyType = NewPopulatedAuthorizationPolicy_Quorum(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy_Quorum(r randyClient, easy bool) *AuthorizationPolicy_Quorum {
	this := &AuthorizationPolicy_Quorum{}
	this.Quorum = NewPopulatedQuorumExpr(r, easy)
	return this
}
func NewPopulatedPublicKey(r randyClient, easy bool) *PublicKey {
	this := &PublicKey{}
	oneofNumber_PubkeyType := []int32{1}[r.Intn(1)]
	switch oneofNumber_PubkeyType {
	case 1:
		this.PubkeyType = NewPopulatedPublicKey_Ed25519(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPublicKey_Ed25519(r randyClient, easy bool) *PublicKey_Ed25519 {
	this := &PublicKey_Ed25519{}
	v31 := r.Intn(100)
	this.Ed25519 = make([]byte, v31)
	for i := 0; i < v31; i++ {
		this.Ed25519[i] = byte(r.Intn(256))
	}
	return this
}
func NewPopulatedQuorumExpr(r randyClient, easy bool) *QuorumExpr {
	this := &QuorumExpr{}
	this.Threshold = uint32(r.Uint32())
	v32 := r.Intn(100)
	this.Candidates = make([]uint64, v32)
	for i := 0; i < v32; i++ {
		this.Candidates[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(10) != 0 {
		v33 := r.Intn(2)
		this.Subexpressions = make([]*QuorumExpr, v33)
		for i := 0; i < v33; i++ {
			this.Subexpressions[i] = NewPopulatedQuorumExpr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyClient interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneClient(r randyClient) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringClient(r randyClient) string {
	v34 := r.Intn(100)
	tmps := make([]rune, v34)
	for i := 0; i < v34; i++ {
		tmps[i] = randUTF8RuneClient(r)
	}
	return string(tmps)
}
func randUnrecognizedClient(r randyClient, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldClient(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldClient(data []byte, r randyClient, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateClient(data, uint64(key))
		v35 := r.Int63()
		if r.Intn(2) == 0 {
			v35 *= -1
		}
		data = encodeVarintPopulateClient(data, uint64(v35))
	case 1:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateClient(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateClient(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateClient(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.QuorumRequirement != nil {
		l = m.QuorumRequirement.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *UpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	l = m.Profile.Size()
	n += 1 + l + sovClient(uint64(l))
	if m.LookupParameters != nil {
		l = m.LookupParameters.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.DKIMProof != nil {
		l = len(m.DKIMProof)
		if l > 0 {
			n += 2 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *LookupProof) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.IndexProof != nil {
		l = len(m.IndexProof)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Ratifications) > 0 {
		for _, e := range m.Ratifications {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.TreeProof != nil {
		l = m.TreeProof.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *TreeProof) Size() (n int) {
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			l = len(b)
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingIndex != nil {
		l = len(m.ExistingIndex)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingEntryHash != nil {
		l = len(m.ExistingEntryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovClient(uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		l = m.UpdatePolicy.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.ProfileCommitment != nil {
		l = len(m.ProfileCommitment)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *SignedEntryUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.NewEntry.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Profile) Size() (n int) {
	var l int
	_ = l
	if m.Nonce != nil {
		l = len(m.Nonce)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Keys) > 0 {
		for k, v := range m.Keys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SignedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TimestampedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *EpochHead) Size() (n int) {
	var l int
	_ = l
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	if m.RootHash != nil {
		l = len(m.RootHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	l = m.IssueTime.Size()
	n += 1 + l + sovClient(uint64(l))
	if m.PreviousSummaryHash != nil {
		l = len(m.PreviousSummaryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	l = m.NextEpochPolicy.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *AuthorizationPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for k, v := range m.PublicKeys {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + 8 + 1 + l + sovClient(uint64(l))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	if m.PolicyType != nil {
		n += m.PolicyType.Size()
	}
	return n
}

func (m *AuthorizationPolicy_Quorum) Size() (n int) {
	var l int
	_ = l
	if m.Quorum != nil {
		l = m.Quorum.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}
func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	if m.PubkeyType != nil {
		n += m.PubkeyType.Size()
	}
	return n
}

func (m *PublicKey_Ed25519) Size() (n int) {
	var l int
	_ = l
	if m.Ed25519 != nil {
		l = len(m.Ed25519)
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}
func (m *QuorumExpr) Size() (n int) {
	var l int
	_ = l
	if m.Threshold != 0 {
		n += 1 + sovClient(uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		n += 9 * len(m.Candidates)
	}
	if len(m.Subexpressions) > 0 {
		for _, e := range m.Subexpressions {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func sovClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClient(x uint64) (n int) {
	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LookupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupRequest{`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`QuorumRequirement:` + strings.Replace(fmt.Sprintf("%v", this.QuorumRequirement), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateRequest{`,
		`Update:` + strings.Replace(fmt.Sprintf("%v", this.Update), "SignedEntryUpdate", "SignedEntryUpdate", 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`LookupParameters:` + strings.Replace(fmt.Sprintf("%v", this.LookupParameters), "LookupRequest", "LookupRequest", 1) + `,`,
		`DKIMProof:` + fmt.Sprintf("%v", this.DKIMProof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookupProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupProof{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`IndexProof:` + fmt.Sprintf("%v", this.IndexProof) + `,`,
		`Ratifications:` + strings.Replace(fmt.Sprintf("%v", this.Ratifications), "SignedEpochHead", "SignedEpochHead", 1) + `,`,
		`TreeProof:` + strings.Replace(fmt.Sprintf("%v", this.TreeProof), "TreeProof", "TreeProof", 1) + `,`,
		`Entry:` + strings.Replace(fmt.Sprintf("%v", this.Entry), "Entry", "Entry", 1) + `,`,
		`Profile:` + strings.Replace(fmt.Sprintf("%v", this.Profile), "Profile", "Profile", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeProof{`,
		`Neighbors:` + fmt.Sprintf("%v", this.Neighbors) + `,`,
		`ExistingIndex:` + fmt.Sprintf("%v", this.ExistingIndex) + `,`,
		`ExistingEntryHash:` + fmt.Sprintf("%v", this.ExistingEntryHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`UpdatePolicy:` + strings.Replace(fmt.Sprintf("%v", this.UpdatePolicy), "AuthorizationPolicy", "AuthorizationPolicy", 1) + `,`,
		`ProfileCommitment:` + fmt.Sprintf("%v", this.ProfileCommitment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEntryUpdate) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEntryUpdate{`,
		`NewEntry:` + strings.Replace(strings.Replace(this.NewEntry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *Profile) String() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%v: %v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&Profile{`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`Keys:` + mapStringForKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "TimestampedEpochHead", "TimestampedEpochHead", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimestampedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimestampedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "EpochHead", "EpochHead", 1), `&`, ``, 1) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(this.Timestamp.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EpochHead{`,
		`Realm:` + fmt.Sprintf("%v", this.Realm) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`RootHash:` + fmt.Sprintf("%v", this.RootHash) + `,`,
		`IssueTime:` + strings.Replace(strings.Replace(this.IssueTime.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`PreviousSummaryHash:` + fmt.Sprintf("%v", this.PreviousSummaryHash) + `,`,
		`NextEpochPolicy:` + strings.Replace(strings.Replace(this.NextEpochPolicy.String(), "AuthorizationPolicy", "AuthorizationPolicy", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy) String() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%v: %v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&AuthorizationPolicy{`,
		`PublicKeys:` + mapStringForPublicKeys + `,`,
		`PolicyType:` + fmt.Sprintf("%v", this.PolicyType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy_Quorum) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizationPolicy_Quorum{`,
		`Quorum:` + strings.Replace(fmt.Sprintf("%v", this.Quorum), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey{`,
		`PubkeyType:` + fmt.Sprintf("%v", this.PubkeyType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey_Ed25519) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey_Ed25519{`,
		`Ed25519:` + fmt.Sprintf("%v", this.Ed25519) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuorumExpr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuorumExpr{`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Candidates:` + fmt.Sprintf("%v", this.Candidates) + `,`,
		`Subexpressions:` + strings.Replace(fmt.Sprintf("%v", this.Subexpressions), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClient(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumRequirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumRequirement == nil {
				m.QuorumRequirement = &QuorumExpr{}
			}
			if err := m.QuorumRequirement.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &SignedEntryUpdate{}
			}
			if err := m.Update.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupParameters == nil {
				m.LookupParameters = &LookupRequest{}
			}
			if err := m.LookupParameters.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DKIMProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DKIMProof = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexProof = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratifications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ratifications = append(m.Ratifications, &SignedEpochHead{})
			if err := m.Ratifications[len(m.Ratifications)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeProof == nil {
				m.TreeProof = &TreeProof{}
			}
			if err := m.TreeProof.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &EncodedEntry{}
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &EncodedProfile{}
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, make([]byte, postIndex-iNdEx))
			copy(m.Neighbors[len(m.Neighbors)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingIndex = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingEntryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingEntryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePolicy == nil {
				m.UpdatePolicy = &AuthorizationPolicy{}
			}
			if err := m.UpdatePolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileCommitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileCommitment = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEntryUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEntryUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEntryUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthClient
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Keys == nil {
				m.Keys = make(map[string][]byte)
			}
			m.Keys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthClient
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimestampedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimestampedEpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimestampedEpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssueTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IssueTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousSummaryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousSummaryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextEpochPolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthClient
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthClient
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &PublicKey{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.PublicKeys == nil {
				m.PublicKeys = make(map[uint64]*PublicKey)
			}
			m.PublicKeys[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QuorumExpr{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &AuthorizationPolicy_Quorum{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ed25519", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, data[iNdEx:postIndex])
			m.PubkeyType = &PublicKey_Ed25519{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumExpr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidates", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Candidates = append(m.Candidates, v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subexpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subexpressions = append(m.Subexpressions, &QuorumExpr{})
			if err := m.Subexpressions[len(m.Subexpressions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClient(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClient(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClient   = fmt.Errorf("proto: integer overflow")
)
